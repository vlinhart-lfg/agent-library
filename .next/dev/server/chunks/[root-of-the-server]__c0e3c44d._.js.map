{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/v.linhart/Desktop/agent-library-2/agent-library/lib/make-api.ts"],"sourcesContent":["export interface ScrapedScenarioData {\n    title: string;\n    description: string;\n    instructions: string;\n    apps: string;\n    appIcons: Array<{ url: string; color: string; name: string }>;\n    authorName: string;\n    makeScenarioId: string;\n    iframeUrl: string;\n    buttonUrl: string;\n    useCase?: string;\n    complexity?: 'Beginner' | 'Intermediate' | 'Advanced';\n    tags?: string[];\n    createdDate?: string;\n}\n\n/**\n * Scrapes icon colors from the Make.com scenario page HTML\n */\nasync function scrapeIconColors(makeScenarioUrl: string): Promise<Map<string, string>> {\n    try {\n        const response = await fetch(makeScenarioUrl);\n        const html = await response.text();\n\n        const colorMap = new Map<string, string>();\n\n        // Match all pkg-icon divs with their background colors and image sources\n        // Example: <div class=\"pkg-icon\" style=\"background-color: rgb(239, 41, 27);\"><img src=\"static/img/packages/google-email_64.png\"\n        const iconRegex = /<div[^>]*class=\"[^\"]*pkg-icon[^\"]*\"[^>]*style=\"[^\"]*background-color:\\s*([^;]+);[^>]*>[\\s\\S]*?<img[^>]*src=\"[^\"]*packages\\/([^_]+)_/g;\n\n        let match;\n        while ((match = iconRegex.exec(html)) !== null) {\n            const color = match[1].trim();\n            const packageId = match[2];\n            colorMap.set(packageId, color);\n        }\n\n        return colorMap;\n    } catch (error) {\n        console.error('Failed to scrape icon colors:', error);\n        return new Map();\n    }\n}\n\n/**\n * Fetches scenario data directly from Make.com API\n * @param makeScenarioUrl - Full URL to Make.com shared scenario\n * @returns Scraped scenario data\n */\nexport async function getScenarioData(makeScenarioUrl: string): Promise<ScrapedScenarioData> {\n    try {\n        // Validate URL\n        if (!makeScenarioUrl.includes('make.com/public/shared-scenario')) {\n            throw new Error('Invalid Make.com scenario URL');\n        }\n\n        // Extract region and scenario ID from URL\n        // Format: https://eu2.make.com/public/shared-scenario/8MrnUpeVs8c/...\n        const urlObj = new URL(makeScenarioUrl);\n        const hostnameParts = urlObj.hostname.split('.');\n        const region = hostnameParts[0]; // e.g., 'eu2', 'us1', 'www'\n\n        const pathParts = urlObj.pathname.split('/');\n        const scenarioIdIndex = pathParts.indexOf('shared-scenario') + 1;\n        const makeScenarioId = pathParts[scenarioIdIndex];\n\n        if (!makeScenarioId) {\n            throw new Error('Could not extract scenario ID from URL');\n        }\n\n        // Construct API URL\n        // Endpoint: https://{region}.make.com/api/v2/public/scenarios-shared/{id}\n        // Note: If region is 'www' or missing, it might default to 'eu1' or similar, but usually shared URLs have the region.\n        // We'll use the hostname from the input URL to be safe.\n        const apiUrl = `https://${urlObj.hostname}/api/v2/public/scenarios-shared/${makeScenarioId}`;\n\n        // Fetch data\n        const response = await fetch(apiUrl);\n\n        if (!response.ok) {\n            throw new Error(`Failed to fetch data from Make.com API: ${response.status} ${response.statusText}`);\n        }\n\n        const data = await response.json();\n        const scenario = data.scenarioShared;\n\n        if (!scenario) {\n            throw new Error('Invalid API response: scenarioShared not found');\n        }\n\n        // Map fields\n        const title = scenario.title || 'Untitled Scenario';\n        const description = scenario.descriptionShort || '';\n        const instructions = scenario.descriptionLong || '';\n\n\n        const appsList = Array.isArray(scenario.scenarioUsedPackages)\n            ? scenario.scenarioUsedPackages\n            : [];\n\n        const apps = appsList.join(', ');\n\n        // Scrape actual icon colors from the Make.com page\n        const colorMap = await scrapeIconColors(makeScenarioUrl);\n\n        // Fallback color function if scraping fails\n        const stringToColor = (str: string): string => {\n            let hash = 0;\n            for (let i = 0; i < str.length; i++) {\n                hash = str.charCodeAt(i) + ((hash << 5) - hash);\n            }\n            const hue = Math.abs(hash % 360);\n            const saturation = 65 + (Math.abs(hash) % 20);\n            const lightness = 45 + (Math.abs(hash >> 8) % 15);\n            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;\n        };\n\n        // Generate icon URLs with colors (use scraped colors or fallback to hash-based)\n        const appIcons = appsList.map((pkg: string) => ({\n            url: `/api/proxy-image?url=${encodeURIComponent(`https://${urlObj.hostname}/static/img/packages/${pkg}_32.png`)}`,\n            color: colorMap.get(pkg) || stringToColor(pkg),\n            name: pkg\n        }));\n\n        const authorName = scenario.name || '';\n\n        // Construct iframe URL\n        // Pattern: https://{region}.make.com/public/shared-scenario/standalone-inspector-previewer/{id}\n        const iframeUrl = `https://${urlObj.hostname}/public/shared-scenario/standalone-inspector-previewer/${makeScenarioId}`;\n\n        return {\n            title,\n            description,\n            instructions,\n            apps,\n            appIcons,\n            authorName,\n            makeScenarioId,\n            iframeUrl,\n            buttonUrl: makeScenarioUrl,\n        };\n    } catch (error: any) {\n        throw new Error(`Failed to fetch scenario data: ${error.message}`);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 152, "column": 0}, "map": {"version":3,"sources":["file:///Users/v.linhart/Desktop/agent-library-2/agent-library/app/api/scrape/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport { getScenarioData } from '@/lib/make-api';\n\n// Rate limiting map (in-memory)\nconst rateLimit = new Map<string, { count: number; timestamp: number }>();\nconst RATE_LIMIT_WINDOW = 3600000; // 1 hour\nconst MAX_SCRAPES_PER_HOUR = parseInt(process.env.RATE_LIMIT_SCRAPES_PER_HOUR || '50');\n\nconst scrapeSchema = z.object({\n  makeScenarioUrl: z.string().url(),\n  enhance: z.boolean().optional(),\n});\n\nexport async function POST(request: Request) {\n  try {\n    // 1. Rate Limiting\n    const ip = request.headers.get('x-forwarded-for') || 'unknown';\n    const now = Date.now();\n    const userLimit = rateLimit.get(ip) || { count: 0, timestamp: now };\n\n    if (now - userLimit.timestamp > RATE_LIMIT_WINDOW) {\n      userLimit.count = 0;\n      userLimit.timestamp = now;\n    }\n\n    if (userLimit.count >= MAX_SCRAPES_PER_HOUR) {\n      return NextResponse.json(\n        { error: 'Rate limit exceeded. Please try again later.' },\n        { status: 429 }\n      );\n    }\n\n    userLimit.count++;\n    rateLimit.set(ip, userLimit);\n\n    // 2. Input Validation\n    const body = await request.json();\n    const validation = scrapeSchema.safeParse(body);\n\n    if (!validation.success) {\n      return NextResponse.json(\n        { error: 'Invalid URL provided' },\n        { status: 400 }\n      );\n    }\n\n    const { makeScenarioUrl } = validation.data;\n\n    // 3. Fetch Data from Make.com API\n    try {\n      const data = await getScenarioData(makeScenarioUrl);\n      return NextResponse.json({ success: true, data });\n    } catch (error: any) {\n      console.error('Scraping failed:', error);\n      return NextResponse.json(\n        { error: error.message || 'Failed to fetch scenario data' },\n        { status: 500 }\n      );\n    }\n\n  } catch (error) {\n    console.error('API Error:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,gCAAgC;AAChC,MAAM,YAAY,IAAI;AACtB,MAAM,oBAAoB,SAAS,SAAS;AAC5C,MAAM,uBAAuB,SAAS,QAAQ,GAAG,CAAC,2BAA2B,IAAI;AAEjF,MAAM,eAAe,yKAAC,CAAC,MAAM,CAAC;IAC5B,iBAAiB,yKAAC,CAAC,MAAM,GAAG,GAAG;IAC/B,SAAS,yKAAC,CAAC,OAAO,GAAG,QAAQ;AAC/B;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,mBAAmB;QACnB,MAAM,KAAK,QAAQ,OAAO,CAAC,GAAG,CAAC,sBAAsB;QACrD,MAAM,MAAM,KAAK,GAAG;QACpB,MAAM,YAAY,UAAU,GAAG,CAAC,OAAO;YAAE,OAAO;YAAG,WAAW;QAAI;QAElE,IAAI,MAAM,UAAU,SAAS,GAAG,mBAAmB;YACjD,UAAU,KAAK,GAAG;YAClB,UAAU,SAAS,GAAG;QACxB;QAEA,IAAI,UAAU,KAAK,IAAI,sBAAsB;YAC3C,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA+C,GACxD;gBAAE,QAAQ;YAAI;QAElB;QAEA,UAAU,KAAK;QACf,UAAU,GAAG,CAAC,IAAI;QAElB,sBAAsB;QACtB,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,aAAa,aAAa,SAAS,CAAC;QAE1C,IAAI,CAAC,WAAW,OAAO,EAAE;YACvB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAuB,GAChC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,EAAE,eAAe,EAAE,GAAG,WAAW,IAAI;QAE3C,kCAAkC;QAClC,IAAI;YACF,MAAM,OAAO,MAAM,IAAA,uIAAe,EAAC;YACnC,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;gBAAM;YAAK;QACjD,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,oBAAoB;YAClC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO,MAAM,OAAO,IAAI;YAAgC,GAC1D;gBAAE,QAAQ;YAAI;QAElB;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,cAAc;QAC5B,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}