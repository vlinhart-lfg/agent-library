module.exports = [
"[project]/node_modules/apify-client/package.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"name":"apify-client","version":"2.20.0","description":"Apify API client for JavaScript","main":"dist/index.js","module":"dist/index.mjs","types":"dist/index.d.ts","browser":"dist/bundle.js","unpkg":"dist/bundle.js","exports":{"./package.json":"./package.json",".":{"import":"./dist/index.mjs","require":"./dist/index.js","types":"./dist/index.d.ts","browser":"./dist/bundle.js"}},"keywords":["apify","api","apifier","crawler","scraper"],"author":{"name":"Apify","email":"support@apify.com","url":"https://apify.com"},"contributors":["Jan Curn <jan@apify.com>","Marek Trunkát <marek@apify.com>","Ondra Urban <ondra@apify.com>","Jakub Drobník <jakub.drobnik@apify.com>"],"license":"Apache-2.0","repository":{"type":"git","url":"git+https://github.com/apify/apify-client-js"},"bugs":{"url":"https://github.com/apify/apify-client-js/issues"},"homepage":"https://docs.apify.com/api/client/js/","files":["dist","!dist/*.tsbuildinfo"],"scripts":{"build":"npm run clean && npm run build:node && npm run build:browser","postbuild":"gen-esm-wrapper dist/index.js dist/index.mjs","prepublishOnly":"(test $CI || (echo \"Publishing is reserved to CI!\"; exit 1))","clean":"rimraf dist","test":"npm run build && jest","lint":"eslint","lint:fix":"eslint --fix","tsc-check-tests":"tsc --noEmit --project test/tsconfig.json","format":"prettier --write .","format:check":"prettier --check .","build:node":"tsc","build:browser":"rsbuild build"},"dependencies":{"@apify/consts":"^2.42.0","@apify/log":"^2.2.6","@apify/utilities":"^2.23.2","@crawlee/types":"^3.3.0","ansi-colors":"^4.1.1","async-retry":"^1.3.3","axios":"^1.6.7","content-type":"^1.0.5","ow":"^0.28.2","tslib":"^2.5.0","type-fest":"^4.0.0"},"devDependencies":{"@apify/eslint-config":"^1.0.0","@apify/tsconfig":"^0.1.1","@babel/cli":"^7.21.0","@babel/core":"^7.21.0","@babel/preset-env":"^7.20.2","@babel/register":"^7.21.0","@crawlee/puppeteer":"^3.2.2","@rsbuild/core":"^1.3.6","@rsbuild/plugin-node-polyfill":"^1.3.0","@stylistic/eslint-plugin-ts":"^4.2.0","@types/async-retry":"^1.4.5","@types/content-type":"^1.1.5","@types/express":"^5.0.0","@types/fs-extra":"^11.0.1","@types/jest":"^29.4.0","@types/node":"^24.0.0","ajv":"^8.17.1","babel-loader":"^10.0.0","body-parser":"^1.20.3","compression":"^1.7.4","eslint":"^9.24.0","eslint-config-prettier":"^10.1.2","express":"^5.0.0","fs-extra":"^11.1.0","gen-esm-wrapper":"^1.1.2","globals":"^16.0.0","jest":"^29.4.3","prettier":"^3.5.3","process":"^0.11.10","puppeteer":"^24.0.0","rimraf":"^6.0.0","source-map-support":"^0.5.21","ts-jest":"^29.0.5","ts-loader":"^9.4.2","ts-node":"^10.9.1","typescript":"^5.8.3","typescript-eslint":"^8.29.1"},"packageManager":"npm@10.9.2"});}),
"[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PaginationIterator = void 0;
exports.pluckData = pluckData;
exports.catchNotFoundOrThrow = catchNotFoundOrThrow;
exports.parseDateFields = parseDateFields;
exports.stringifyWebhooksToBase64 = stringifyWebhooksToBase64;
exports.maybeGzipValue = maybeGzipValue;
exports.sliceArrayByByteLength = sliceArrayByByteLength;
exports.isNode = isNode;
exports.isBuffer = isBuffer;
exports.isStream = isStream;
exports.getVersionData = getVersionData;
exports.cast = cast;
exports.asArray = asArray;
exports.applyQueryParamsToUrl = applyQueryParamsToUrl;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const NOT_FOUND_STATUS_CODE = 404;
const RECORD_NOT_FOUND_TYPE = 'record-not-found';
const RECORD_OR_TOKEN_NOT_FOUND_TYPE = 'record-or-token-not-found';
const MIN_GZIP_BYTES = 1024;
/**
 * Returns object's 'data' property or throws if parameter is not an object,
 * or an object without a 'data' property.
 */ function pluckData(obj) {
    if (typeof obj === 'object' && obj) {
        if (typeof obj.data !== 'undefined') return obj.data;
    }
    throw new Error(`Expected response object with a "data" property, but received: ${obj}`);
}
/**
 * If given HTTP error has NOT_FOUND_STATUS_CODE status code then returns undefined.
 * Otherwise rethrows error.
 */ function catchNotFoundOrThrow(err) {
    const isNotFoundStatus = err.statusCode === NOT_FOUND_STATUS_CODE;
    const isNotFoundMessage = err.type === RECORD_NOT_FOUND_TYPE || err.type === RECORD_OR_TOKEN_NOT_FOUND_TYPE || err.httpMethod === 'head';
    const isNotFoundError = isNotFoundStatus && isNotFoundMessage;
    if (!isNotFoundError) throw err;
}
/**
 * Traverses JSON structure and converts fields that end with "At" to a Date object (fields such as "modifiedAt" or
 * "createdAt").
 *
 * If you want parse other fields as well, you can provide a custom matcher function shouldParseField(). This
 * admittedly awkward approach allows this function to be reused for various purposes without introducing potential
 * breaking changes.
 *
 * If the field cannot be converted to Date, it is left as is.
 */ function parseDateFields(input, shouldParseField = null, depth = 0) {
    // Don't go too deep to avoid stack overflows (especially if there is a circular reference). The depth of 3
    // corresponds to obj.data.someArrayField.[x].field and should be generally enough.
    // TODO: Consider removing this limitation. It might came across as an annoying surprise as it's not communicated.
    if (depth > 3) {
        return input;
    }
    if (Array.isArray(input)) return input.map((child)=>parseDateFields(child, shouldParseField, depth + 1));
    if (!input || typeof input !== 'object') return input;
    return Object.entries(input).reduce((output, [k, v])=>{
        const isValObject = !!v && typeof v === 'object';
        if (k.endsWith('At') || shouldParseField && shouldParseField(k)) {
            if (v) {
                const d = new Date(v);
                output[k] = Number.isNaN(d.getTime()) ? v : d;
            } else {
                output[k] = v;
            }
        } else if (isValObject || Array.isArray(v)) {
            output[k] = parseDateFields(v, shouldParseField, depth + 1);
        } else {
            output[k] = v;
        }
        return output;
    }, {});
}
/**
 * Helper function that converts array of webhooks to base64 string
 */ function stringifyWebhooksToBase64(webhooks) {
    if (!webhooks) return;
    const webhooksJson = JSON.stringify(webhooks);
    if (isNode()) {
        return Buffer.from(webhooksJson, 'utf8').toString('base64');
    }
    const encoder = new TextEncoder();
    const uint8Array = encoder.encode(webhooksJson);
    return btoa(String.fromCharCode(...uint8Array));
}
let gzipPromisified;
/**
 * Gzip provided value, otherwise returns undefined.
 */ async function maybeGzipValue(value) {
    if (!isNode()) return;
    if (typeof value !== 'string' && !Buffer.isBuffer(value)) return;
    // Request compression is not that important so let's
    // skip it instead of throwing for unsupported types.
    const areDataLargeEnough = Buffer.byteLength(value) >= MIN_GZIP_BYTES;
    if (areDataLargeEnough) {
        if (!gzipPromisified) {
            const { promisify } = await Promise.resolve().then(()=>tslib_1.__importStar(__turbopack_context__.r("[externals]/node:util [external] (node:util, cjs)")));
            const { gzip } = await Promise.resolve().then(()=>tslib_1.__importStar(__turbopack_context__.r("[externals]/node:zlib [external] (node:zlib, cjs)")));
            gzipPromisified = promisify(gzip);
        }
        return gzipPromisified(value);
    }
    return undefined;
}
/**
 * Helper function slice the items from array to fit the max byte length.
 */ function sliceArrayByByteLength(array, maxByteLength, startIndex) {
    const stringByteLength = (str)=>isNode() ? Buffer.byteLength(str) : new Blob([
            str
        ]).size;
    const arrayByteLength = stringByteLength(JSON.stringify(array));
    if (arrayByteLength < maxByteLength) return array;
    const slicedArray = [];
    let byteLength = 2; // 2 bytes for the empty array []
    for(let i = 0; i < array.length; i++){
        const item = array[i];
        const itemByteSize = stringByteLength(JSON.stringify(item));
        if (itemByteSize > maxByteLength) {
            throw new Error(`RequestQueueClient.batchAddRequests: The size of the request with index: ${startIndex + i} ` + `exceeds the maximum allowed size (${maxByteLength} bytes).`);
        }
        if (byteLength + itemByteSize >= maxByteLength) break;
        byteLength += itemByteSize;
        slicedArray.push(item);
    }
    return slicedArray;
}
function isNode() {
    return !!(typeof process !== 'undefined' && process.versions && process.versions.node);
}
function isBuffer(value) {
    return ow_1.default.isValid(value, ow_1.default.any(ow_1.default.buffer, ow_1.default.arrayBuffer, ow_1.default.typedArray));
}
function isStream(value) {
    return ow_1.default.isValid(value, ow_1.default.object.hasKeys('on', 'pipe'));
}
function getVersionData() {
    if (typeof BROWSER_BUILD !== 'undefined') {
        return {
            version: VERSION
        };
    }
    // eslint-disable-next-line
    return __turbopack_context__.r("[project]/node_modules/apify-client/package.json (json)");
}
/**
 * Helper class to create async iterators from paginated list endpoints with exclusive start key.
 */ class PaginationIterator {
    constructor(options){
        Object.defineProperty(this, "maxPageLimit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "getPage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "limit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "exclusiveStartId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.maxPageLimit = options.maxPageLimit;
        this.limit = options.limit;
        this.exclusiveStartId = options.exclusiveStartId;
        this.getPage = options.getPage;
    }
    async *[Symbol.asyncIterator]() {
        let nextPageExclusiveStartId;
        let iterateItemCount = 0;
        while(true){
            const pageLimit = this.limit ? Math.min(this.maxPageLimit, this.limit - iterateItemCount) : this.maxPageLimit;
            const pageExclusiveStartId = nextPageExclusiveStartId || this.exclusiveStartId;
            const page = await this.getPage({
                limit: pageLimit,
                exclusiveStartId: pageExclusiveStartId
            });
            // There are no more pages to iterate
            if (page.items.length === 0) return;
            yield page;
            iterateItemCount += page.items.length;
            // Limit reached stopping to iterate
            if (this.limit && iterateItemCount >= this.limit) return;
            nextPageExclusiveStartId = page.items[page.items.length - 1].id;
        }
    }
}
exports.PaginationIterator = PaginationIterator;
function cast(input) {
    return input;
}
function asArray(value) {
    if (Array.isArray(value)) {
        return value;
    }
    return [
        value
    ];
}
/**
 * Adds query parameters to a given URL based on the provided options object.
 */ function applyQueryParamsToUrl(url, options) {
    for (const [key, value] of Object.entries(options !== null && options !== void 0 ? options : {})){
        // skip undefined values
        if (value === undefined) continue;
        // join array values with a comma
        if (Array.isArray(value)) {
            url.searchParams.set(key, value.join(','));
            continue;
        }
        url.searchParams.set(key, String(value));
    }
    return url;
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/apify-client/dist/body_parser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.maybeParseBody = maybeParseBody;
exports.isomorphicBufferToString = isomorphicBufferToString;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const content_type_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/content-type/index.js [app-route] (ecmascript)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
const CONTENT_TYPE_JSON = 'application/json';
const STRINGIFIABLE_CONTENT_TYPE_RXS = [
    new RegExp(`^${CONTENT_TYPE_JSON}`, 'i'),
    /^application\/.*xml$/i,
    /^text\//i
];
/**
 * Parses a Buffer or ArrayBuffer using the provided content type header.
 *
 * - application/json is returned as a parsed object.
 * - application/*xml and text/* are returned as strings.
 * - everything else is returned as original body.
 *
 * If the header includes a charset, the body will be stringified only
 * if the charset represents a known encoding to Node.js or Browser.
 */ function maybeParseBody(body, contentTypeHeader) {
    let contentType;
    let charset;
    try {
        const result = content_type_1.default.parse(contentTypeHeader);
        contentType = result.type;
        charset = result.parameters.charset;
    } catch  {
        // can't parse, keep original body
        return body;
    }
    // If we can't successfully parse it, we return
    // the original buffer rather than a mangled string.
    if (!areDataStringifiable(contentType, charset)) return body;
    const dataString = isomorphicBufferToString(body, charset);
    return contentType === CONTENT_TYPE_JSON ? JSON.parse(dataString) : dataString;
}
function isomorphicBufferToString(buffer, encoding) {
    if (buffer.constructor.name !== ArrayBuffer.name) {
        return buffer.toString(encoding);
    }
    // Browser decoding only works with UTF-8.
    const utf8decoder = new TextDecoder();
    return utf8decoder.decode(new Uint8Array(buffer));
}
function isCharsetStringifiable(charset) {
    if (!charset) return true; // hope that it's utf-8
    if ((0, utils_1.isNode)()) return Buffer.isEncoding(charset);
    const normalizedCharset = charset.toLowerCase().replace('-', '');
    // Browsers only support decoding utf-8 buffers.
    return normalizedCharset === 'utf8';
}
function isContentTypeStringifiable(contentType) {
    if (!contentType) return false; // keep buffer
    return STRINGIFIABLE_CONTENT_TYPE_RXS.some((rx)=>rx.test(contentType));
}
function areDataStringifiable(contentType, charset) {
    return isContentTypeStringifiable(contentType) && isCharsetStringifiable(charset);
} //# sourceMappingURL=body_parser.js.map
}),
"[project]/node_modules/apify-client/dist/apify_api_error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApifyApiError = void 0;
const body_parser_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/body_parser.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
/**
 * Examples of capturing groups for "...at ActorCollectionClient._list (/Users/..."
 * 0: "at ActorCollectionClient._list ("
 * 1: undefined
 * 2: "ActorCollectionClient"
 * 3: undefined
 * 4: "list"
 * @private
 */ const CLIENT_METHOD_REGEX = /at( async)? ([A-Za-z]+(Collection)?Client)\._?([A-Za-z]+) \(/;
/**
 * An `ApifyApiError` is thrown for successful HTTP requests that reach the API,
 * but the API responds with an error response. Typically, those are rate limit
 * errors and internal errors, which are automatically retried, or validation
 * errors, which are thrown immediately, because a correction by the user is
 * needed.
 */ class ApifyApiError extends Error {
    /**
     * @hidden
     */ constructor(response, attempt){
        var _a;
        let message;
        let type;
        let responseData = response.data;
        let errorData;
        // Some methods (e.g. downloadItems) set up forceBuffer on request response. If this request failed
        // the body buffer needs to parse to get the correct error.
        if ((0, utils_1.isBuffer)(responseData)) {
            try {
                responseData = JSON.parse((0, body_parser_1.isomorphicBufferToString)(response.data, 'utf-8'));
            } catch  {
            // This can happen. The data in the response body are malformed.
            }
        }
        if (responseData && responseData.error) {
            const { error } = responseData;
            message = error.message;
            type = error.type;
            errorData = error.data;
        } else if (responseData) {
            let dataString;
            try {
                dataString = JSON.stringify(responseData, null, 2);
            } catch  {
                dataString = `${responseData}`;
            }
            message = `Unexpected error: ${dataString}`;
        }
        super(message);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The invoked resource client and the method. Known issue: Sometimes it displays
         * as `unknown` because it can't be parsed from a stack trace.
         */ Object.defineProperty(this, "clientMethod", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * HTTP status code of the error.
         */ Object.defineProperty(this, "statusCode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The type of the error, as returned by the API.
         */ Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Number of the API call attempt.
         */ Object.defineProperty(this, "attempt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * HTTP method of the API call.
         */ Object.defineProperty(this, "httpMethod", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Full path of the API endpoint (URL excluding origin).
         */ Object.defineProperty(this, "path", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Original stack trace of the exception. It is replaced
         * by a more informative stack with API call information.
         */ Object.defineProperty(this, "originalStack", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Additional data provided by the API about the error
         */ Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = this.constructor.name;
        this.clientMethod = this._extractClientAndMethodFromStack();
        this.statusCode = response.status;
        this.type = type;
        this.attempt = attempt;
        this.httpMethod = (_a = response.config) === null || _a === void 0 ? void 0 : _a.method;
        this.path = this._safelyParsePathFromResponse(response);
        const stack = this.stack;
        this.originalStack = stack.slice(stack.indexOf('\n'));
        this.stack = this._createApiStack();
        this.data = errorData;
    }
    _safelyParsePathFromResponse(response) {
        var _a;
        const urlString = (_a = response.config) === null || _a === void 0 ? void 0 : _a.url;
        let url;
        try {
            url = new URL(urlString);
        } catch  {
            return urlString;
        }
        return url.pathname + url.search;
    }
    _extractClientAndMethodFromStack() {
        const match = this.stack.match(CLIENT_METHOD_REGEX);
        if (match) return `${match[2]}.${match[4]}`;
        return 'unknown';
    }
    /**
     * Creates a better looking and more informative stack that will be printed
     * out when API errors are thrown.
     *
     * Example:
     *
     * ApifyApiError: Actor task was not found
     *   clientMethod: TaskClient.start
     *   statusCode: 404
     *   type: record-not-found
     *   attempt: 1
     *   httpMethod: post
     *   path: /v2/actor-tasks/user~my-task/runs
     */ _createApiStack() {
        const { name, ...props } = this;
        const stack = Object.entries(props).map(([k, v])=>{
            // Rename originalStack to stack in the stack itself.
            // This is for better readability of errors in log.
            if (k === 'originalStack') k = 'stack';
            return `  ${k}: ${v}`;
        }).join('\n');
        return `${name}: ${this.message}\n${stack}`;
    }
}
exports.ApifyApiError = ApifyApiError; //# sourceMappingURL=apify_api_error.js.map
}),
"[project]/node_modules/apify-client/dist/interceptors.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.responseInterceptors = exports.requestInterceptors = exports.InvalidResponseBodyError = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const axios_1 = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/axios/dist/node/axios.cjs [app-route] (ecmascript)"));
const content_type_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/content-type/index.js [app-route] (ecmascript)"));
const body_parser_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/body_parser.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
/**
 * This error exists for the quite common situation, where only a partial JSON response is received and
 * an attempt to parse the JSON throws an error. In most cases this can be resolved by retrying the
 * request. We do that by identifying this error in HttpClient.
 *
 * The properties mimic AxiosError for easier integration in HttpClient error handling.
 */ class InvalidResponseBodyError extends Error {
    constructor(response, cause){
        super(`Response body could not be parsed.\nCause:${cause.message}`);
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = this.constructor.name;
        this.code = 'invalid-response-body';
        this.response = response;
        this.cause = cause;
    }
}
exports.InvalidResponseBodyError = InvalidResponseBodyError;
function serializeRequest(config) {
    var _a, _b;
    const [defaultTransform] = axios_1.default.defaults.transformRequest;
    // The function not only serializes data, but it also adds correct headers.
    const data = defaultTransform(config.data, config.headers);
    // Actor inputs can include functions and we don't want to omit those,
    // because it's convenient for users. JSON.stringify removes them.
    // It's a bit inefficient that we serialize the JSON twice, but I feel
    // it's a small price to pay. The axios default transform does a lot
    // of body type checks and we would have to copy all of them to the resource clients.
    if (config.stringifyFunctions) {
        const contentTypeHeader = ((_a = config.headers) === null || _a === void 0 ? void 0 : _a['Content-Type']) || ((_b = config.headers) === null || _b === void 0 ? void 0 : _b['content-type']);
        try {
            const { type } = content_type_1.default.parse(contentTypeHeader);
            if (type === 'application/json' && typeof config.data === 'object') {
                config.data = stringifyWithFunctions(config.data);
            } else {
                config.data = data;
            }
        } catch  {
            config.data = data;
        }
    } else {
        config.data = data;
    }
    return config;
}
function ensureHeadersPrototype(config) {
    if (config.headers && !(config.headers instanceof axios_1.AxiosHeaders)) {
        Object.setPrototypeOf(config.headers, axios_1.AxiosHeaders.prototype);
    }
    return config;
}
/**
 * JSON.stringify() that serializes functions to string instead
 * of replacing them with null or removing them.
 */ function stringifyWithFunctions(obj) {
    return JSON.stringify(obj, (_key, value)=>{
        return typeof value === 'function' ? value.toString() : value;
    });
}
async function maybeGzipRequest(config) {
    var _a, _b;
    if ((_a = config.headers) === null || _a === void 0 ? void 0 : _a['content-encoding']) return config;
    const maybeZippedData = await (0, utils_1.maybeGzipValue)(config.data);
    if (maybeZippedData) {
        (_b = config.headers) !== null && _b !== void 0 ? _b : config.headers = {};
        config.headers['content-encoding'] = 'gzip';
        config.data = maybeZippedData;
    }
    return config;
}
function parseResponseData(response) {
    if (!response.data || // Nothing to do here.
    response.config.responseType !== 'arraybuffer' || // We don't want to parse custom response types.
    response.config.forceBuffer // Apify custom property to prevent parsing of buffer.
    ) {
        return response;
    }
    const isBufferEmpty = (0, utils_1.isNode)() ? !response.data.length : !response.data.byteLength;
    if (isBufferEmpty) {
        // undefined is better than an empty buffer
        response.data = undefined;
        return response;
    }
    const contentTypeHeader = response.headers['content-type'];
    try {
        response.data = (0, body_parser_1.maybeParseBody)(response.data, contentTypeHeader);
    } catch (err) {
        throw new InvalidResponseBodyError(response, err);
    }
    return response;
}
exports.requestInterceptors = [
    maybeGzipRequest,
    serializeRequest,
    ensureHeadersPrototype
];
exports.responseInterceptors = [
    parseResponseData
]; //# sourceMappingURL=interceptors.js.map
}),
"[project]/node_modules/apify-client/dist/http_client.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const node_http_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:http [external] (node:http, cjs)"));
const node_https_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:https [external] (node:https, cjs)"));
const node_os_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:os [external] (node:os, cjs)"));
const async_retry_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/async-retry/lib/index.js [app-route] (ecmascript)"));
const axios_1 = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/axios/dist/node/axios.cjs [app-route] (ecmascript)"));
const consts_1 = __turbopack_context__.r("[project]/node_modules/@apify/consts/cjs/index.cjs [app-route] (ecmascript)");
const apify_api_error_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/apify_api_error.js [app-route] (ecmascript)");
const interceptors_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/interceptors.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
const { version } = (0, utils_1.getVersionData)();
const RATE_LIMIT_EXCEEDED_STATUS_CODE = 429;
class HttpClient {
    constructor(options){
        Object.defineProperty(this, "stats", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "maxRetries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "minDelayBetweenRetriesMillis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "userProvidedRequestInterceptors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "timeoutMillis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "httpAgent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "httpsAgent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "axios", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "workflowKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const { token } = options;
        this.stats = options.apifyClientStats;
        this.maxRetries = options.maxRetries;
        this.minDelayBetweenRetriesMillis = options.minDelayBetweenRetriesMillis;
        this.userProvidedRequestInterceptors = options.requestInterceptors;
        this.timeoutMillis = options.timeoutSecs * 1000;
        this.logger = options.logger;
        this.workflowKey = options.workflowKey || process.env[consts_1.APIFY_ENV_VARS.WORKFLOW_KEY];
        this._onRequestRetry = this._onRequestRetry.bind(this);
        if ((0, utils_1.isNode)()) {
            // We want to keep sockets alive for better performance.
            // Enhanced agent configuration based on agentkeepalive best practices:
            // - Nagle's algorithm disabled for lower latency
            // - Free socket timeout to prevent socket leaks
            // - LIFO scheduling to reuse recent sockets
            // - Socket TTL for connection freshness
            const agentOptions = {
                keepAlive: true,
                // Timeout for inactive sockets
                // Prevents socket leaks from idle connections
                timeout: this.timeoutMillis,
                // Keep alive timeout for free sockets (15 seconds)
                // Node.js will close unused sockets after this period
                keepAliveMsecs: 15000,
                // Maximum number of sockets per host
                maxSockets: 256,
                maxFreeSockets: 256,
                // LIFO scheduling - reuse most recently used sockets for better performance
                scheduling: 'lifo'
            };
            this.httpAgent = new node_http_1.default.Agent(agentOptions);
            this.httpsAgent = new node_https_1.default.Agent(agentOptions);
            // Disable Nagle's algorithm for lower latency
            // This sends data immediately instead of buffering small packets
            const setNoDelay = (socket)=>{
                socket.setNoDelay(true);
            };
            this.httpAgent.on('socket', setNoDelay);
            this.httpsAgent.on('socket', setNoDelay);
        }
        this.axios = axios_1.default.create({
            httpAgent: this.httpAgent,
            httpsAgent: this.httpsAgent,
            paramsSerializer: (params)=>{
                const formattedParams = Object.entries(params).filter(([, value])=>value !== undefined).map(([key, value])=>{
                    if (value instanceof Date) {
                        return [
                            key,
                            value.toISOString()
                        ];
                    }
                    const updatedValue = typeof value === 'boolean' ? Number(value) : value;
                    return [
                        key,
                        String(updatedValue)
                    ];
                });
                return new URLSearchParams(formattedParams).toString();
            },
            validateStatus: null,
            // Using interceptors for this functionality.
            transformRequest: undefined,
            transformResponse: undefined,
            responseType: 'arraybuffer',
            timeout: this.timeoutMillis,
            // maxBodyLength needs to be Infinity, because -1 falls back to a 10 MB default
            // from an axios subdependency - 'follow-redirects'
            maxBodyLength: Infinity,
            // maxContentLength must be -1, because Infinity will cause axios to run super slow
            // thanks to a bug that's now fixed, but not released yet https://github.com/axios/axios/pull/3738
            maxContentLength: -1
        });
        // Clean all default headers because they only make a mess and their merging is difficult to understand and buggy.
        this.axios.defaults.headers = new axios_1.AxiosHeaders();
        // If workflow key is available, pass it as a header
        if (this.workflowKey) {
            this.axios.defaults.headers['X-Apify-Workflow-Key'] = this.workflowKey;
        }
        if ((0, utils_1.isNode)()) {
            // Works only in Node. Cannot be set in browser
            const isAtHome = !!process.env[consts_1.APIFY_ENV_VARS.IS_AT_HOME];
            let userAgent = `ApifyClient/${version} (${node_os_1.default.type()}; Node/${process.version}); isAtHome/${isAtHome}`;
            if (options.userAgentSuffix) {
                userAgent += `; ${(0, utils_1.asArray)(options.userAgentSuffix).join('; ')}`;
            }
            this.axios.defaults.headers['User-Agent'] = userAgent;
        }
        // Attach Authorization header for all requests if token was provided
        if (token) {
            this.axios.defaults.headers.Authorization = `Bearer ${token}`;
        }
        interceptors_1.requestInterceptors.forEach((i)=>this.axios.interceptors.request.use(i));
        this.userProvidedRequestInterceptors.forEach((i)=>this.axios.interceptors.request.use(i));
        interceptors_1.responseInterceptors.forEach((i)=>this.axios.interceptors.response.use(i));
    }
    async call(config) {
        this.stats.calls++;
        const makeRequest = this._createRequestHandler(config);
        return (0, async_retry_1.default)(makeRequest, {
            retries: this.maxRetries,
            minTimeout: this.minDelayBetweenRetriesMillis,
            onRetry: this._onRequestRetry
        });
    }
    _informAboutStreamNoRetry() {
        this.logger.warningOnce('Request body was a stream - retrying will not work, as part of it was already consumed.');
        this.logger.warningOnce('If you want Apify client to handle retries for you, collect the stream into a buffer before sending it.');
    }
    /**
     * Successful responses are returned, errors and unsuccessful
     * status codes are retried. See the following functions for the
     * retrying logic.
     */ _createRequestHandler(config) {
        const makeRequest = async (stopTrying, attempt)=>{
            var _a;
            this.stats.requests++;
            let response;
            const requestIsStream = (0, utils_1.isStream)(config.data);
            try {
                if (requestIsStream) {
                    // Handling redirects is not possible without buffering - part of the stream has already been sent and can't be recovered
                    // when server sends the redirect. Therefore we need to override this in Axios config to prevent it from buffering the body.
                    // see also axios/axios#1045
                    config = {
                        ...config,
                        maxRedirects: 0
                    };
                }
                // Increase timeout with each attempt. Max timeout is bounded by the client timeout.
                config.timeout = Math.min(this.timeoutMillis, ((_a = config.timeout) !== null && _a !== void 0 ? _a : this.timeoutMillis) * 2 ** (attempt - 1));
                response = await this.axios.request(config);
                if (this._isStatusOk(response.status)) return response;
            } catch (err) {
                return (0, utils_1.cast)(this._handleRequestError(err, config, stopTrying));
            }
            if (response.status === RATE_LIMIT_EXCEEDED_STATUS_CODE) {
                this.stats.addRateLimitError(attempt);
            }
            const apiError = new apify_api_error_1.ApifyApiError(response, attempt);
            if (this._isStatusCodeRetryable(response.status)) {
                if (requestIsStream) {
                    this._informAboutStreamNoRetry();
                } else {
                    // allow a retry
                    throw apiError;
                }
            }
            stopTrying(apiError);
            return response;
        };
        return makeRequest;
    }
    _isStatusOk(statusCode) {
        return statusCode < 300;
    }
    /**
     * Handles all unexpected errors that can happen, but are not
     * Apify API typed errors. E.g. network errors, timeouts and so on.
     */ _handleRequestError(err, config, stopTrying) {
        if (this._isTimeoutError(err) && config.doNotRetryTimeouts) {
            return stopTrying(err);
        }
        if (this._isRetryableError(err)) {
            if ((0, utils_1.isStream)(config.data)) {
                this._informAboutStreamNoRetry();
            } else {
                throw err;
            }
        }
        return stopTrying(err);
    }
    /**
     * Axios calls req.abort() on timeouts so timeout errors will
     * have a code ECONNABORTED.
     */ _isTimeoutError(err) {
        return err.code === 'ECONNABORTED';
    }
    /**
     * We don't want to retry every exception thrown from Axios.
     * The common denominator for retryable errors are network issues.
     * @param {Error} err
     * @private
     */ _isRetryableError(err) {
        return this._isNetworkError(err) || this._isResponseBodyInvalid(err);
    }
    /**
     * When a network connection to our API is interrupted in the middle of streaming
     * a response, the request often does not fail, but simply contains
     * an incomplete response. This can often be fixed by retrying.
     */ _isResponseBodyInvalid(err) {
        return err instanceof interceptors_1.InvalidResponseBodyError;
    }
    /**
     * When a network request is attempted by axios and fails,
     * it throws an AxiosError, which will have the request
     * and config (and other) properties.
     */ _isNetworkError(err) {
        const hasRequest = err.request && typeof err.request === 'object';
        const hasConfig = err.config && typeof err.config === 'object';
        return hasRequest && hasConfig;
    }
    /**
     * We retry 429 (rate limit) and 500+.
     * For status codes 300-499 (except 429) we do not retry the request,
     * because it's probably caused by invalid url (redirect 3xx) or invalid user input (4xx).
     */ _isStatusCodeRetryable(statusCode) {
        const isRateLimitError = statusCode === RATE_LIMIT_EXCEEDED_STATUS_CODE;
        const isInternalError = statusCode >= 500;
        return isRateLimitError || isInternalError;
    }
    _onRequestRetry(error, attempt) {
        if (attempt === Math.round(this.maxRetries / 2)) {
            this.logger.warning(`API request failed ${attempt} times. Max attempts: ${this.maxRetries + 1}.\nCause:${error.stack}`);
        }
    }
}
exports.HttpClient = HttpClient; //# sourceMappingURL=http_client.js.map
}),
"[project]/node_modules/apify-client/dist/base/api_client.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApiClient = void 0;
/** @private */ class ApiClient {
    constructor(options){
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "safeId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "baseUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "publicBaseUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resourcePath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "apifyClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "httpClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const { baseUrl, publicBaseUrl, apifyClient, httpClient, resourcePath, id, params = {} } = options;
        this.id = id;
        this.safeId = id && this._toSafeId(id);
        this.baseUrl = baseUrl;
        this.publicBaseUrl = publicBaseUrl;
        this.resourcePath = resourcePath;
        this.url = id ? `${baseUrl}/${resourcePath}/${this.safeId}` : `${baseUrl}/${resourcePath}`;
        this.apifyClient = apifyClient;
        this.httpClient = httpClient;
        this.params = params;
    }
    _subResourceOptions(moreOptions) {
        const baseOptions = {
            baseUrl: this._url(),
            publicBaseUrl: this.publicBaseUrl,
            apifyClient: this.apifyClient,
            httpClient: this.httpClient,
            params: this._params()
        };
        return {
            ...baseOptions,
            ...moreOptions
        };
    }
    _url(path) {
        return path ? `${this.url}/${path}` : this.url;
    }
    _publicUrl(path) {
        const url = this.id ? `${this.publicBaseUrl}/${this.resourcePath}/${this.safeId}` : `${this.publicBaseUrl}/${this.resourcePath}`;
        return path ? `${url}/${path}` : url;
    }
    _params(endpointParams) {
        return {
            ...this.params,
            ...endpointParams
        };
    }
    _toSafeId(id) {
        // The id has the format `username/actor-name`, so we only need to replace the first `/`.
        return id.replace('/', '~');
    }
}
exports.ApiClient = ApiClient; //# sourceMappingURL=api_client.js.map
}),
"[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResourceClient = exports.DEFAULT_TIMEOUT_MILLIS = exports.MEDIUM_TIMEOUT_MILLIS = exports.SMALL_TIMEOUT_MILLIS = void 0;
const consts_1 = __turbopack_context__.r("[project]/node_modules/@apify/consts/cjs/index.cjs [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
const api_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/api_client.js [app-route] (ecmascript)");
/**
 * We need to supply some number for the API,
 * because it would not accept "Infinity".
 * 999999 seconds is more than 10 days.
 */ const MAX_WAIT_FOR_FINISH = 999999;
exports.SMALL_TIMEOUT_MILLIS = 5 * 1000; // For fast and common actions. Suitable for idempotent actions.
exports.MEDIUM_TIMEOUT_MILLIS = 30 * 1000; // For actions that may take longer.
exports.DEFAULT_TIMEOUT_MILLIS = 360 * 1000; // 6 minutes
/**
 * Resource client.
 * @private
 */ class ResourceClient extends api_client_1.ApiClient {
    async _get(options = {}, timeoutMillis) {
        const requestOpts = {
            url: this._url(),
            method: 'GET',
            params: this._params(options),
            timeout: timeoutMillis
        };
        try {
            const response = await this.httpClient.call(requestOpts);
            return (0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data));
        } catch (err) {
            (0, utils_1.catchNotFoundOrThrow)(err);
        }
        return undefined;
    }
    async _update(newFields, timeoutMillis) {
        const response = await this.httpClient.call({
            url: this._url(),
            method: 'PUT',
            params: this._params(),
            data: newFields,
            timeout: timeoutMillis
        });
        return (0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data));
    }
    async _delete(timeoutMillis) {
        try {
            await this.httpClient.call({
                url: this._url(),
                method: 'DELETE',
                params: this._params(),
                timeout: timeoutMillis
            });
        } catch (err) {
            (0, utils_1.catchNotFoundOrThrow)(err);
        }
    }
    /**
     * This function is used in Build and Run endpoints so it's kept
     * here to stay DRY.
     */ async _waitForFinish(options = {}) {
        const { waitSecs = MAX_WAIT_FOR_FINISH } = options;
        const waitMillis = waitSecs * 1000;
        let job;
        const startedAt = Date.now();
        const shouldRepeat = ()=>{
            const millisSinceStart = Date.now() - startedAt;
            if (millisSinceStart >= waitMillis) return false;
            const hasJobEnded = job && consts_1.ACT_JOB_TERMINAL_STATUSES.includes(job.status);
            return !hasJobEnded;
        };
        do {
            const millisSinceStart = Date.now() - startedAt;
            const remainingWaitSeconds = Math.round((waitMillis - millisSinceStart) / 1000);
            const waitForFinish = Math.max(0, remainingWaitSeconds);
            const requestOpts = {
                url: this._url(),
                method: 'GET',
                params: this._params({
                    waitForFinish
                })
            };
            try {
                const response = await this.httpClient.call(requestOpts);
                job = (0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data));
            } catch (err) {
                (0, utils_1.catchNotFoundOrThrow)(err);
                job = undefined;
            }
            // It might take some time for database replicas to get up-to-date,
            // so getRun() might return null. Wait a little bit and try it again.
            if (!job) await new Promise((resolve)=>{
                setTimeout(resolve, 250);
            });
        }while (shouldRepeat())
        if (!job) {
            const constructorName = this.constructor.name;
            const jobName = constructorName.match(/(\w+)Client/)[1].toLowerCase();
            throw new Error(`Waiting for ${jobName} to finish failed. Cannot fetch actor ${jobName} details from the server.`);
        }
        return job;
    }
}
exports.ResourceClient = ResourceClient; //# sourceMappingURL=resource_client.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/actor_env_var.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ActorEnvVarClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
class ActorEnvVarClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'env-vars',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/environment-variable-object/get-environment-variable
     */ async get() {
        return this._get();
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/environment-variable-object/update-environment-variable
     */ async update(actorEnvVar) {
        (0, ow_1.default)(actorEnvVar, ow_1.default.object);
        return this._update(actorEnvVar);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/environment-variable-object/delete-environment-variable
     */ async delete() {
        return this._delete();
    }
}
exports.ActorEnvVarClient = ActorEnvVarClient; //# sourceMappingURL=actor_env_var.js.map
}),
"[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResourceCollectionClient = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
const api_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/api_client.js [app-route] (ecmascript)");
/**
 * Resource collection client.
 * @private
 */ class ResourceCollectionClient extends api_client_1.ApiClient {
    /**
     * @private
     */ async _list(options = {}) {
        const response = await this.httpClient.call({
            url: this._url(),
            method: 'GET',
            params: this._params(options)
        });
        return (0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data));
    }
    async _create(resource) {
        const response = await this.httpClient.call({
            url: this._url(),
            method: 'POST',
            params: this._params(),
            data: resource
        });
        return (0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data));
    }
    async _getOrCreate(name, resource) {
        const response = await this.httpClient.call({
            url: this._url(),
            method: 'POST',
            params: this._params({
                name
            }),
            data: resource
        });
        return (0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data));
    }
}
exports.ResourceCollectionClient = ResourceCollectionClient; //# sourceMappingURL=resource_collection_client.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/actor_env_var_collection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ActorEnvVarCollectionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_collection_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)");
class ActorEnvVarCollectionClient extends resource_collection_client_1.ResourceCollectionClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'env-vars',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/environment-variable-collection/get-list-of-environment-variables
     */ async list(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            desc: ow_1.default.optional.boolean
        }));
        return this._list(options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/environment-variable-collection/create-environment-variable
     */ async create(actorEnvVar) {
        (0, ow_1.default)(actorEnvVar, ow_1.default.optional.object);
        return this._create(actorEnvVar);
    }
}
exports.ActorEnvVarCollectionClient = ActorEnvVarCollectionClient; //# sourceMappingURL=actor_env_var_collection.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/actor_version.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ActorSourceType = exports.ActorVersionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
const actor_env_var_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/actor_env_var.js [app-route] (ecmascript)");
const actor_env_var_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/actor_env_var_collection.js [app-route] (ecmascript)");
class ActorVersionClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'versions',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/version-object/get-version
     */ async get() {
        return this._get();
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/version-object/update-version
     */ async update(newFields) {
        (0, ow_1.default)(newFields, ow_1.default.object);
        return this._update(newFields);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/version-object/delete-version
     */ async delete() {
        return this._delete();
    }
    /**
     * TODO: https://docs.apify.com/api/v2#/reference/actors/env-var-object
     */ envVar(envVarName) {
        (0, ow_1.default)(envVarName, ow_1.default.string);
        return new actor_env_var_1.ActorEnvVarClient(this._subResourceOptions({
            id: envVarName
        }));
    }
    /**
     * TODO: https://docs.apify.com/api/v2#/reference/actors/env-var-collection
     * @return {ActorVersionCollectionClient}
     */ envVars() {
        return new actor_env_var_collection_1.ActorEnvVarCollectionClient(this._subResourceOptions());
    }
}
exports.ActorVersionClient = ActorVersionClient;
var ActorSourceType;
(function(ActorSourceType) {
    ActorSourceType["SourceFiles"] = "SOURCE_FILES";
    ActorSourceType["GitRepo"] = "GIT_REPO";
    ActorSourceType["Tarball"] = "TARBALL";
    ActorSourceType["GitHubGist"] = "GITHUB_GIST";
})(ActorSourceType || (exports.ActorSourceType = ActorSourceType = {})); //# sourceMappingURL=actor_version.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/actor_version_collection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ActorVersionCollectionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_collection_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)");
class ActorVersionCollectionClient extends resource_collection_client_1.ResourceCollectionClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'versions',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/version-collection/get-list-of-versions
     */ async list(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            desc: ow_1.default.optional.boolean
        }));
        return this._list(options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/version-collection/create-version
     */ async create(actorVersion) {
        (0, ow_1.default)(actorVersion, ow_1.default.optional.object);
        return this._create(actorVersion);
    }
}
exports.ActorVersionCollectionClient = ActorVersionCollectionClient; //# sourceMappingURL=actor_version_collection.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/log.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StreamedLog = exports.LoggerActorRedirect = exports.LogClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ansi_colors_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ansi-colors/index.js [app-route] (ecmascript)"));
const log_1 = __turbopack_context__.r("[project]/node_modules/@apify/log/cjs/index.cjs [app-route] (ecmascript)");
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
class LogClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'logs',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/logs/log/get-log
     */ async get(options = {}) {
        const requestOpts = {
            url: this._url(),
            method: 'GET',
            params: this._params(options)
        };
        try {
            const response = await this.httpClient.call(requestOpts);
            return (0, utils_1.cast)(response.data);
        } catch (err) {
            (0, utils_1.catchNotFoundOrThrow)(err);
        }
        return undefined;
    }
    /**
     * Gets the log in a Readable stream format. Only works in Node.js.
     * https://docs.apify.com/api/v2#/reference/logs/log/get-log
     */ async stream(options = {}) {
        const params = {
            stream: true,
            raw: options.raw
        };
        const requestOpts = {
            url: this._url(),
            method: 'GET',
            params: this._params(params),
            responseType: 'stream'
        };
        try {
            const response = await this.httpClient.call(requestOpts);
            return (0, utils_1.cast)(response.data);
        } catch (err) {
            (0, utils_1.catchNotFoundOrThrow)(err);
        }
        return undefined;
    }
}
exports.LogClient = LogClient;
/**
 * Logger for redirected actor logs.
 */ class LoggerActorRedirect extends log_1.Logger {
    constructor(options = {}){
        super({
            skipTime: true,
            level: log_1.LogLevel.DEBUG,
            ...options
        });
    }
    _log(level, message, data, exception, opts = {}) {
        if (level > this.options.level) {
            return;
        }
        if (data || exception) {
            throw new Error('Redirect logger does not use other arguments than level and message');
        }
        let { prefix } = opts;
        prefix = prefix ? `${prefix}` : '';
        let maybeDate = '';
        if (!this.options.skipTime) {
            maybeDate = `${new Date().toISOString().replace('Z', '').replace('T', ' ')} `;
        }
        const line = `${ansi_colors_1.default.gray(maybeDate)}${ansi_colors_1.default.cyan(prefix)}${message || ''}`;
        // All redirected logs are logged at info level to avid any console specific formating for non-info levels,
        // which have already been applied once to the original log. (For example error stack traces etc.)
        this._outputWithConsole(log_1.LogLevel.INFO, line);
        return line;
    }
}
exports.LoggerActorRedirect = LoggerActorRedirect;
/**
 * Helper class for redirecting streamed Actor logs to another log.
 */ class StreamedLog {
    constructor(options){
        Object.defineProperty(this, "destinationLog", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "streamBuffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "splitMarker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: /(?:\n|^)(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)/g
        });
        Object.defineProperty(this, "relevancyTimeLimit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "logClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "streamingTask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "stopLogging", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        const { toLog, logClient, fromStart = true } = options;
        this.destinationLog = toLog;
        this.logClient = logClient;
        this.relevancyTimeLimit = fromStart ? null : new Date();
    }
    /**
     * Start log redirection.
     */ start() {
        if (this.streamingTask) {
            throw new Error('Streaming task already active');
        }
        this.stopLogging = false;
        this.streamingTask = this.streamLog();
    }
    /**
     * Stop log redirection.
     */ async stop() {
        if (!this.streamingTask) {
            throw new Error('Streaming task is not active');
        }
        this.stopLogging = true;
        try {
            await this.streamingTask;
        } catch (err) {
            if (!(err instanceof Error && err.name === 'AbortError')) {
                throw err;
            }
        } finally{
            this.streamingTask = null;
        }
    }
    /**
     * Get log stream from response and redirect it to another log.
     */ async streamLog() {
        const logStream = await this.logClient.stream({
            raw: true
        });
        if (!logStream) {
            return;
        }
        const lastChunkRemainder = await this.logStreamChunks(logStream);
        // Process whatever is left when exiting. Maybe it is incomplete, maybe it is last log without EOL.
        const lastMessage = Buffer.from(lastChunkRemainder).toString().trim();
        if (lastMessage.length) {
            this.destinationLog.info(lastMessage);
        }
    }
    async logStreamChunks(logStream) {
        // Chunk may be incomplete. Keep remainder for next chunk.
        let previousChunkRemainder = new Uint8Array();
        for await (const chunk of logStream){
            // Handle possible leftover incomplete line from previous chunk.
            // Everything before last end of line is complete.
            const chunkWithPreviousRemainder = new Uint8Array(previousChunkRemainder.length + chunk.length);
            chunkWithPreviousRemainder.set(previousChunkRemainder, 0);
            chunkWithPreviousRemainder.set(chunk, previousChunkRemainder.length);
            const lastCompleteMessageIndex = chunkWithPreviousRemainder.lastIndexOf(0x0a);
            previousChunkRemainder = chunkWithPreviousRemainder.slice(lastCompleteMessageIndex);
            // Push complete part of the chunk to the buffer
            this.streamBuffer.push(Buffer.from(chunkWithPreviousRemainder.slice(0, lastCompleteMessageIndex)));
            this.logBufferContent();
            // Keep processing the new data until stopped
            if (this.stopLogging) {
                break;
            }
        }
        return previousChunkRemainder;
    }
    /**
     * Parse the buffer and log complete messages.
     */ logBufferContent() {
        const allParts = Buffer.concat(this.streamBuffer).toString().split(this.splitMarker).slice(1);
        // Parse the buffer parts into complete messages
        const messageMarkers = allParts.filter((_, i)=>i % 2 === 0);
        const messageContents = allParts.filter((_, i)=>i % 2 !== 0);
        this.streamBuffer = [];
        messageMarkers.forEach((marker, index)=>{
            const decodedMarker = marker;
            const decodedContent = messageContents[index];
            if (this.relevancyTimeLimit) {
                // Log only relevant messages. Ignore too old log messages.
                const logTime = new Date(decodedMarker);
                if (logTime < this.relevancyTimeLimit) {
                    return;
                }
            }
            const message = decodedMarker + decodedContent;
            // Original log level information is not available. Log all on info level. Log level could be guessed for
            // some logs, but for any multiline logs such guess would be probably correct only for the first line.
            this.destinationLog.info(message.trim());
        });
    }
}
exports.StreamedLog = StreamedLog; //# sourceMappingURL=log.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/build.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BuildClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
const log_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/log.js [app-route] (ecmascript)");
class BuildClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'actor-builds',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-builds/build-object/get-build
     */ async get(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            waitForFinish: ow_1.default.optional.number
        }));
        return this._get(options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-builds/abort-build/abort-build
     */ async abort() {
        const response = await this.httpClient.call({
            url: this._url('abort'),
            method: 'POST',
            params: this._params()
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-builds/delete-build/delete-build
     */ async delete() {
        return this._delete();
    }
    /**
     * https://docs.apify.com/api/v2/actor-build-openapi-json-get
     */ async getOpenApiDefinition() {
        const response = await this.httpClient.call({
            url: this._url('openapi.json'),
            method: 'GET',
            params: this._params()
        });
        return response.data;
    }
    /**
     * Returns a promise that resolves with the finished Build object when the provided actor build finishes
     * or with the unfinished Build object when the `waitSecs` timeout lapses. The promise is NOT rejected
     * based on run status. You can inspect the `status` property of the Build object to find out its status.
     *
     * The difference between this function and the `waitForFinish` parameter of the `get` method
     * is the fact that this function can wait indefinitely. Its use is preferable to the
     * `waitForFinish` parameter alone, which it uses internally.
     *
     * This is useful when you need to immediately start a run after a build finishes.
     */ async waitForFinish(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            waitSecs: ow_1.default.optional.number
        }));
        return this._waitForFinish(options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-builds/build-log
     */ log() {
        return new log_1.LogClient(this._subResourceOptions({
            resourcePath: 'log'
        }));
    }
}
exports.BuildClient = BuildClient; //# sourceMappingURL=build.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/build_collection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BuildCollectionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_collection_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)");
class BuildCollectionClient extends resource_collection_client_1.ResourceCollectionClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            ...options,
            resourcePath: options.resourcePath || 'actor-builds'
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/build-collection/get-list-of-builds
     */ async list(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            desc: ow_1.default.optional.boolean
        }));
        return this._list(options);
    }
}
exports.BuildCollectionClient = BuildCollectionClient; //# sourceMappingURL=build_collection.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/dataset.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DownloadItemsFormat = exports.DatasetClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const utilities_1 = __turbopack_context__.r("[project]/node_modules/@apify/utilities/cjs/index.cjs [app-route] (ecmascript)");
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
class DatasetClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'datasets',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/datasets/dataset/get-dataset
     */ async get() {
        return this._get({}, resource_client_1.SMALL_TIMEOUT_MILLIS);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/datasets/dataset/update-dataset
     */ async update(newFields) {
        (0, ow_1.default)(newFields, ow_1.default.object);
        return this._update(newFields, resource_client_1.SMALL_TIMEOUT_MILLIS);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/datasets/dataset/delete-dataset
     */ async delete() {
        return this._delete(resource_client_1.SMALL_TIMEOUT_MILLIS);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/datasets/item-collection/get-items
     */ async listItems(options = {}) {
        var _a;
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            clean: ow_1.default.optional.boolean,
            desc: ow_1.default.optional.boolean,
            flatten: ow_1.default.optional.array.ofType(ow_1.default.string),
            fields: ow_1.default.optional.array.ofType(ow_1.default.string),
            omit: ow_1.default.optional.array.ofType(ow_1.default.string),
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            skipEmpty: ow_1.default.optional.boolean,
            skipHidden: ow_1.default.optional.boolean,
            unwind: ow_1.default.optional.any(ow_1.default.string, ow_1.default.array.ofType(ow_1.default.string)),
            view: ow_1.default.optional.string,
            signature: ow_1.default.optional.string
        }));
        const response = await this.httpClient.call({
            url: this._url('items'),
            method: 'GET',
            params: this._params(options),
            timeout: resource_client_1.DEFAULT_TIMEOUT_MILLIS
        });
        return this._createPaginationList(response, (_a = options.desc) !== null && _a !== void 0 ? _a : false);
    }
    /**
     * Unlike `listItems` which returns a {@link PaginationList} with an array of individual
     * dataset items, `downloadItems` returns the items serialized to the provided format.
     * https://docs.apify.com/api/v2#/reference/datasets/item-collection/get-items
     */ async downloadItems(format, options = {}) {
        (0, ow_1.default)(format, ow_1.default.string.oneOf(validItemFormats));
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            attachment: ow_1.default.optional.boolean,
            bom: ow_1.default.optional.boolean,
            clean: ow_1.default.optional.boolean,
            delimiter: ow_1.default.optional.string,
            desc: ow_1.default.optional.boolean,
            flatten: ow_1.default.optional.array.ofType(ow_1.default.string),
            fields: ow_1.default.optional.array.ofType(ow_1.default.string),
            omit: ow_1.default.optional.array.ofType(ow_1.default.string),
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            skipEmpty: ow_1.default.optional.boolean,
            skipHeaderRow: ow_1.default.optional.boolean,
            skipHidden: ow_1.default.optional.boolean,
            unwind: ow_1.default.any(ow_1.default.optional.string, ow_1.default.optional.array.ofType(ow_1.default.string)),
            view: ow_1.default.optional.string,
            xmlRoot: ow_1.default.optional.string,
            xmlRow: ow_1.default.optional.string,
            signature: ow_1.default.optional.string
        }));
        const { data } = await this.httpClient.call({
            url: this._url('items'),
            method: 'GET',
            params: this._params({
                format,
                ...options
            }),
            forceBuffer: true,
            timeout: resource_client_1.DEFAULT_TIMEOUT_MILLIS
        });
        return (0, utils_1.cast)(data);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/datasets/item-collection/put-items
     */ async pushItems(items) {
        (0, ow_1.default)(items, ow_1.default.any(ow_1.default.object, ow_1.default.string, ow_1.default.array.ofType(ow_1.default.any(ow_1.default.object, ow_1.default.string))));
        await this.httpClient.call({
            url: this._url('items'),
            method: 'POST',
            headers: {
                'content-type': 'application/json; charset=utf-8'
            },
            data: items,
            params: this._params(),
            doNotRetryTimeouts: true,
            timeout: resource_client_1.MEDIUM_TIMEOUT_MILLIS
        });
    }
    /**
     * https://docs.apify.com/api/v2#tag/DatasetsStatistics/operation/dataset_statistics_get
     */ async getStatistics() {
        const requestOpts = {
            url: this._url('statistics'),
            method: 'GET',
            params: this._params(),
            timeout: resource_client_1.SMALL_TIMEOUT_MILLIS
        };
        try {
            const response = await this.httpClient.call(requestOpts);
            return (0, utils_1.cast)((0, utils_1.pluckData)(response.data));
        } catch (err) {
            (0, utils_1.catchNotFoundOrThrow)(err);
        }
        return undefined;
    }
    /**
     * Generates a URL that can be used to access dataset items.
     *
     * If the client has permission to access the dataset's URL signing key,
     * the URL will include a signature which will allow the link to work even without authentication.
     *
     * You can optionally control how long the signed URL should be valid using the `expiresInSecs` option.
     * This value sets the expiration duration in seconds from the time the URL is generated.
     * If not provided, the URL will not expire.
     *
     * Any other options (like `limit` or `prefix`) will be included as query parameters in the URL.
     */ async createItemsPublicUrl(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            clean: ow_1.default.optional.boolean,
            desc: ow_1.default.optional.boolean,
            flatten: ow_1.default.optional.array.ofType(ow_1.default.string),
            fields: ow_1.default.optional.array.ofType(ow_1.default.string),
            omit: ow_1.default.optional.array.ofType(ow_1.default.string),
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            skipEmpty: ow_1.default.optional.boolean,
            skipHidden: ow_1.default.optional.boolean,
            unwind: ow_1.default.optional.any(ow_1.default.string, ow_1.default.array.ofType(ow_1.default.string)),
            view: ow_1.default.optional.string,
            expiresInSecs: ow_1.default.optional.number
        }));
        const dataset = await this.get();
        const { expiresInSecs, ...queryOptions } = options;
        let createdItemsPublicUrl = new URL(this._publicUrl('items'));
        if (dataset === null || dataset === void 0 ? void 0 : dataset.urlSigningSecretKey) {
            const signature = await (0, utilities_1.createStorageContentSignatureAsync)({
                resourceId: dataset.id,
                urlSigningSecretKey: dataset.urlSigningSecretKey,
                expiresInMillis: expiresInSecs ? expiresInSecs * 1000 : undefined
            });
            createdItemsPublicUrl.searchParams.set('signature', signature);
        }
        createdItemsPublicUrl = (0, utils_1.applyQueryParamsToUrl)(createdItemsPublicUrl, queryOptions);
        return createdItemsPublicUrl.toString();
    }
    _createPaginationList(response, userProvidedDesc) {
        var _a;
        return {
            items: response.data,
            total: Number(response.headers['x-apify-pagination-total']),
            offset: Number(response.headers['x-apify-pagination-offset']),
            count: response.data.length,
            limit: Number(response.headers['x-apify-pagination-limit']),
            // TODO: Replace this once https://github.com/apify/apify-core/issues/3503 is solved
            desc: JSON.parse((_a = response.headers['x-apify-pagination-desc']) !== null && _a !== void 0 ? _a : userProvidedDesc)
        };
    }
}
exports.DatasetClient = DatasetClient;
var DownloadItemsFormat;
(function(DownloadItemsFormat) {
    DownloadItemsFormat["JSON"] = "json";
    DownloadItemsFormat["JSONL"] = "jsonl";
    DownloadItemsFormat["XML"] = "xml";
    DownloadItemsFormat["HTML"] = "html";
    DownloadItemsFormat["CSV"] = "csv";
    DownloadItemsFormat["XLSX"] = "xlsx";
    DownloadItemsFormat["RSS"] = "rss";
})(DownloadItemsFormat || (exports.DownloadItemsFormat = DownloadItemsFormat = {}));
const validItemFormats = [
    ...new Set(Object.values(DownloadItemsFormat).map((item)=>item.toLowerCase()))
]; //# sourceMappingURL=dataset.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/key_value_store.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KeyValueStoreClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const log_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@apify/log/cjs/index.cjs [app-route] (ecmascript)"));
const utilities_1 = __turbopack_context__.r("[project]/node_modules/@apify/utilities/cjs/index.cjs [app-route] (ecmascript)");
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
class KeyValueStoreClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'key-value-stores',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/key-value-stores/store-object/get-store
     */ async get() {
        return this._get({}, resource_client_1.SMALL_TIMEOUT_MILLIS);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/key-value-stores/store-object/update-store
     */ async update(newFields) {
        (0, ow_1.default)(newFields, ow_1.default.object);
        return this._update(newFields, resource_client_1.DEFAULT_TIMEOUT_MILLIS);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/key-value-stores/store-object/delete-store
     */ async delete() {
        return this._delete(resource_client_1.SMALL_TIMEOUT_MILLIS);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/key-value-stores/key-collection/get-list-of-keys
     */ async listKeys(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number,
            exclusiveStartKey: ow_1.default.optional.string,
            collection: ow_1.default.optional.string,
            prefix: ow_1.default.optional.string,
            signature: ow_1.default.optional.string
        }));
        const response = await this.httpClient.call({
            url: this._url('keys'),
            method: 'GET',
            params: this._params(options),
            timeout: resource_client_1.MEDIUM_TIMEOUT_MILLIS
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * Generates a URL that can be used to access key-value store record.
     *
     * If the client has permission to access the key-value store's URL signing key,
     * the URL will include a signature to verify its authenticity.
     */ async getRecordPublicUrl(key) {
        (0, ow_1.default)(key, ow_1.default.string.nonEmpty);
        const store = await this.get();
        const recordPublicUrl = new URL(this._publicUrl(`records/${key}`));
        if (store === null || store === void 0 ? void 0 : store.urlSigningSecretKey) {
            const signature = await (0, utilities_1.createHmacSignatureAsync)(store.urlSigningSecretKey, key);
            recordPublicUrl.searchParams.append('signature', signature);
        }
        return recordPublicUrl.toString();
    }
    /**
     * Generates a URL that can be used to access key-value store keys.
     *
     * If the client has permission to access the key-value store's URL signing key,
     * the URL will include a signature which will allow the link to work even without authentication.
     *
     * You can optionally control how long the signed URL should be valid using the `expiresInSecs` option.
     * This value sets the expiration duration in seconds from the time the URL is generated.
     * If not provided, the URL will not expire.
     *
     * Any other options (like `limit` or `prefix`) will be included as query parameters in the URL.
     */ async createKeysPublicUrl(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number,
            exclusiveStartKey: ow_1.default.optional.string,
            collection: ow_1.default.optional.string,
            prefix: ow_1.default.optional.string,
            expiresInSecs: ow_1.default.optional.number
        }));
        const store = await this.get();
        const { expiresInSecs, ...queryOptions } = options;
        let createdPublicKeysUrl = new URL(this._publicUrl('keys'));
        if (store === null || store === void 0 ? void 0 : store.urlSigningSecretKey) {
            const signature = await (0, utilities_1.createStorageContentSignatureAsync)({
                resourceId: store.id,
                urlSigningSecretKey: store.urlSigningSecretKey,
                expiresInMillis: expiresInSecs ? expiresInSecs * 1000 : undefined
            });
            createdPublicKeysUrl.searchParams.set('signature', signature);
        }
        createdPublicKeysUrl = (0, utils_1.applyQueryParamsToUrl)(createdPublicKeysUrl, queryOptions);
        return createdPublicKeysUrl.toString();
    }
    /**
     * Tests whether a record with the given key exists in the key-value store without retrieving its value.
     *
     * https://docs.apify.com/api/v2#/reference/key-value-stores/record/get-record
     * @param key The queried record key.
     * @returns `true` if the record exists, `false` if it does not.
     */ async recordExists(key) {
        const requestOpts = {
            url: this._url(`records/${key}`),
            method: 'HEAD',
            params: this._params()
        };
        try {
            await this.httpClient.call(requestOpts);
            return true;
        } catch (err) {
            (0, utils_1.catchNotFoundOrThrow)(err);
        }
        return false;
    }
    async getRecord(key, options = {}) {
        (0, ow_1.default)(key, ow_1.default.string);
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            buffer: ow_1.default.optional.boolean,
            stream: ow_1.default.optional.boolean,
            disableRedirect: ow_1.default.optional.boolean,
            signature: ow_1.default.optional.string
        }));
        if (options.stream && !(0, utils_1.isNode)()) {
            throw new Error('The stream option can only be used in Node.js environment.');
        }
        if ('disableRedirect' in options) {
            log_1.default.deprecated('The disableRedirect option for getRecord() is deprecated. ' + 'It has no effect and will be removed in the following major release.');
        }
        const queryParams = {};
        if (options.signature) queryParams.signature = options.signature;
        const requestOpts = {
            url: this._url(`records/${key}`),
            method: 'GET',
            params: this._params(queryParams),
            timeout: resource_client_1.DEFAULT_TIMEOUT_MILLIS
        };
        if (options.buffer) requestOpts.forceBuffer = true;
        if (options.stream) requestOpts.responseType = 'stream';
        try {
            const response = await this.httpClient.call(requestOpts);
            return {
                key,
                value: response.data,
                contentType: response.headers['content-type']
            };
        } catch (err) {
            (0, utils_1.catchNotFoundOrThrow)(err);
        }
        return undefined;
    }
    /**
     * The value in the record can be a stream object (detected by having the `.pipe`
     * and `.on` methods). However, note that in that case following redirects or
     * retrying the request if it fails (for example due to rate limiting) isn't
     * possible. If you want to keep that behavior, you need to collect the whole
     * stream contents into a Buffer and then send the full buffer. See [this
     * StackOverflow answer](https://stackoverflow.com/a/14269536/7292139) for
     * an example how to do that.
     *
     * https://docs.apify.com/api/v2#/reference/key-value-stores/record/put-record
     */ async setRecord(record, options = {}) {
        (0, ow_1.default)(record, ow_1.default.object.exactShape({
            key: ow_1.default.string,
            value: ow_1.default.any(ow_1.default.null, ow_1.default.string, ow_1.default.number, ow_1.default.object, ow_1.default.boolean),
            contentType: ow_1.default.optional.string.nonEmpty
        }));
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            timeoutSecs: ow_1.default.optional.number,
            doNotRetryTimeouts: ow_1.default.optional.boolean
        }));
        const { key } = record;
        let { value, contentType } = record;
        const { timeoutSecs, doNotRetryTimeouts } = options;
        const isValueStreamOrBuffer = (0, utils_1.isStream)(value) || (0, utils_1.isBuffer)(value);
        // To allow saving Objects to JSON without providing content type
        if (!contentType) {
            if (isValueStreamOrBuffer) contentType = 'application/octet-stream';
            else if (typeof value === 'string') contentType = 'text/plain; charset=utf-8';
            else contentType = 'application/json; charset=utf-8';
        }
        const isContentTypeJson = /^application\/json/.test(contentType);
        if (isContentTypeJson && !isValueStreamOrBuffer && typeof value !== 'string') {
            try {
                value = JSON.stringify(value, null, 2);
            } catch (err) {
                const msg = `The record value cannot be stringified to JSON. Please provide other content type.\nCause: ${err.message}`;
                throw new Error(msg);
            }
        }
        const uploadOpts = {
            url: this._url(`records/${key}`),
            method: 'PUT',
            params: this._params(),
            data: value,
            headers: contentType ? {
                'content-type': contentType
            } : undefined,
            doNotRetryTimeouts,
            timeout: timeoutSecs !== undefined ? timeoutSecs * 1000 : resource_client_1.DEFAULT_TIMEOUT_MILLIS
        };
        await this.httpClient.call(uploadOpts);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/key-value-stores/record/delete-record
     */ async deleteRecord(key) {
        (0, ow_1.default)(key, ow_1.default.string);
        await this.httpClient.call({
            url: this._url(`records/${key}`),
            method: 'DELETE',
            params: this._params(),
            timeout: resource_client_1.SMALL_TIMEOUT_MILLIS
        });
    }
}
exports.KeyValueStoreClient = KeyValueStoreClient; //# sourceMappingURL=key_value_store.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/request_queue.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RequestQueueClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const consts_1 = __turbopack_context__.r("[project]/node_modules/@apify/consts/cjs/index.cjs [app-route] (ecmascript)");
const log_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@apify/log/cjs/index.cjs [app-route] (ecmascript)"));
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
const DEFAULT_PARALLEL_BATCH_ADD_REQUESTS = 5;
const DEFAULT_UNPROCESSED_RETRIES_BATCH_ADD_REQUESTS = 3;
const DEFAULT_MIN_DELAY_BETWEEN_UNPROCESSED_REQUESTS_RETRIES_MILLIS = 500;
const DEFAULT_REQUEST_QUEUE_REQUEST_PAGE_LIMIT = 1000;
const SAFETY_BUFFER_PERCENT = 0.01 / 100; // 0.01%
class RequestQueueClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options, userOptions = {}){
        super({
            resourcePath: 'request-queues',
            ...options
        });
        Object.defineProperty(this, "clientKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "timeoutMillis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.clientKey = userOptions.clientKey;
        this.timeoutMillis = userOptions.timeoutSecs ? userOptions.timeoutSecs * 1e3 : undefined;
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/queue/get-request-queue
     */ async get() {
        return this._get({}, resource_client_1.SMALL_TIMEOUT_MILLIS);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/queue/update-request-queue
     */ async update(newFields) {
        (0, ow_1.default)(newFields, ow_1.default.object);
        return this._update(newFields, resource_client_1.SMALL_TIMEOUT_MILLIS);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/queue/delete-request-queue
     */ async delete() {
        return this._delete(resource_client_1.SMALL_TIMEOUT_MILLIS);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/queue-head/get-head
     */ async listHead(options = {}) {
        var _a;
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number
        }));
        const response = await this.httpClient.call({
            url: this._url('head'),
            method: 'GET',
            timeout: Math.min(resource_client_1.SMALL_TIMEOUT_MILLIS, (_a = this.timeoutMillis) !== null && _a !== void 0 ? _a : Infinity),
            params: this._params({
                limit: options.limit,
                clientKey: this.clientKey
            })
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/queue-head-with-locks/get-head-and-lock
     */ async listAndLockHead(options) {
        var _a;
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            lockSecs: ow_1.default.number,
            limit: ow_1.default.optional.number
        }));
        const response = await this.httpClient.call({
            url: this._url('head/lock'),
            method: 'POST',
            timeout: Math.min(resource_client_1.MEDIUM_TIMEOUT_MILLIS, (_a = this.timeoutMillis) !== null && _a !== void 0 ? _a : Infinity),
            params: this._params({
                limit: options.limit,
                lockSecs: options.lockSecs,
                clientKey: this.clientKey
            })
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/request-collection/add-request
     */ async addRequest(request, options = {}) {
        var _a;
        (0, ow_1.default)(request, ow_1.default.object.partialShape({
            id: ow_1.default.undefined
        }));
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            forefront: ow_1.default.optional.boolean
        }));
        const response = await this.httpClient.call({
            url: this._url('requests'),
            method: 'POST',
            timeout: Math.min(resource_client_1.SMALL_TIMEOUT_MILLIS, (_a = this.timeoutMillis) !== null && _a !== void 0 ? _a : Infinity),
            data: request,
            params: this._params({
                forefront: options.forefront,
                clientKey: this.clientKey
            })
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * Writes requests to request queue in batch.
     *
     * @private
     */ async _batchAddRequests(requests, options = {}) {
        var _a;
        (0, ow_1.default)(requests, ow_1.default.array.ofType(ow_1.default.object.partialShape({
            id: ow_1.default.undefined
        })).minLength(1).maxLength(consts_1.REQUEST_QUEUE_MAX_REQUESTS_PER_BATCH_OPERATION));
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            forefront: ow_1.default.optional.boolean
        }));
        const { data } = await this.httpClient.call({
            url: this._url('requests/batch'),
            method: 'POST',
            timeout: Math.min(resource_client_1.MEDIUM_TIMEOUT_MILLIS, (_a = this.timeoutMillis) !== null && _a !== void 0 ? _a : Infinity),
            data: requests,
            params: this._params({
                forefront: options.forefront,
                clientKey: this.clientKey
            })
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(data)));
    }
    async _batchAddRequestsWithRetries(requests, options = {}) {
        const { forefront, maxUnprocessedRequestsRetries = DEFAULT_UNPROCESSED_RETRIES_BATCH_ADD_REQUESTS, minDelayBetweenUnprocessedRequestsRetriesMillis = DEFAULT_MIN_DELAY_BETWEEN_UNPROCESSED_REQUESTS_RETRIES_MILLIS } = options;
        // Keep track of the requests that remain to be processed (in parameter format)
        let remainingRequests = requests;
        // Keep track of the requests that have been processed (in api format)
        const processedRequests = [];
        // The requests we have not been able to process in the last call
        // ie. those we have not been able to process at all
        let unprocessedRequests = [];
        for(let i = 0; i < 1 + maxUnprocessedRequestsRetries; i++){
            try {
                const response = await this._batchAddRequests(remainingRequests, {
                    forefront
                });
                processedRequests.push(...response.processedRequests);
                unprocessedRequests = response.unprocessedRequests;
                // Consider request with unprocessed requests as rate limited.
                // NOTE: This is important for SDK, the rate limit errors are read by AutoScalePool and used to potentially downscale.
                if (unprocessedRequests.length !== 0) {
                    this.httpClient.stats.addRateLimitError(i + 1);
                }
                // Get unique keys of all requests processed so far
                const processedRequestsUniqueKeys = processedRequests.map(({ uniqueKey })=>uniqueKey);
                // Requests remaining to be processed are the all that remain
                remainingRequests = requests.filter(({ uniqueKey })=>!processedRequestsUniqueKeys.includes(uniqueKey));
                // Stop if all requests have been processed
                if (remainingRequests.length === 0) {
                    break;
                }
            } catch (err) {
                log_1.default.exception(err, 'Request batch insert failed');
                // When something fails and http client does not retry, the remaining requests are treated as unprocessed.
                // This ensures that this method does not throw and keeps the signature.
                const processedRequestsUniqueKeys = processedRequests.map(({ uniqueKey })=>uniqueKey);
                unprocessedRequests = requests.filter(({ uniqueKey })=>!processedRequestsUniqueKeys.includes(uniqueKey)).map(({ method, uniqueKey, url })=>({
                        method,
                        uniqueKey,
                        url
                    }));
                break;
            }
            // Exponential backoff
            const delayMillis = Math.floor((1 + Math.random()) * 2 ** i * minDelayBetweenUnprocessedRequestsRetriesMillis);
            await new Promise((resolve)=>{
                setTimeout(resolve, delayMillis);
            });
        }
        const result = {
            processedRequests,
            unprocessedRequests
        };
        return (0, utils_1.cast)((0, utils_1.parseDateFields)(result));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/batch-request-operations/add-requests
     */ async batchAddRequests(requests, options = {}) {
        const { forefront, maxUnprocessedRequestsRetries = DEFAULT_UNPROCESSED_RETRIES_BATCH_ADD_REQUESTS, maxParallel = DEFAULT_PARALLEL_BATCH_ADD_REQUESTS, minDelayBetweenUnprocessedRequestsRetriesMillis = DEFAULT_MIN_DELAY_BETWEEN_UNPROCESSED_REQUESTS_RETRIES_MILLIS } = options;
        (0, ow_1.default)(requests, ow_1.default.array.ofType(ow_1.default.object.partialShape({
            id: ow_1.default.undefined
        })).minLength(1));
        (0, ow_1.default)(forefront, ow_1.default.optional.boolean);
        (0, ow_1.default)(maxUnprocessedRequestsRetries, ow_1.default.optional.number);
        (0, ow_1.default)(maxParallel, ow_1.default.optional.number);
        (0, ow_1.default)(minDelayBetweenUnprocessedRequestsRetriesMillis, ow_1.default.optional.number);
        const executingRequests = new Set();
        const individualResults = [];
        const payloadSizeLimitBytes = consts_1.MAX_PAYLOAD_SIZE_BYTES - Math.ceil(consts_1.MAX_PAYLOAD_SIZE_BYTES * SAFETY_BUFFER_PERCENT);
        // Keep a pool of up to `maxParallel` requests running at once
        let i = 0;
        while(i < requests.length){
            const slicedRequests = requests.slice(i, i + consts_1.REQUEST_QUEUE_MAX_REQUESTS_PER_BATCH_OPERATION);
            const requestsInBatch = (0, utils_1.sliceArrayByByteLength)(slicedRequests, payloadSizeLimitBytes, i);
            const requestPromise = this._batchAddRequestsWithRetries(requestsInBatch, options);
            executingRequests.add(requestPromise);
            void requestPromise.then((batchAddResult)=>{
                executingRequests.delete(requestPromise);
                individualResults.push(batchAddResult);
            });
            if (executingRequests.size >= maxParallel) {
                await Promise.race(executingRequests);
            }
            i += requestsInBatch.length;
        }
        // Get results from remaining operations
        await Promise.all(executingRequests);
        // Combine individual results together
        const result = {
            processedRequests: [],
            unprocessedRequests: []
        };
        individualResults.forEach(({ processedRequests, unprocessedRequests })=>{
            result.processedRequests.push(...processedRequests);
            result.unprocessedRequests.push(...unprocessedRequests);
        });
        return result;
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/batch-request-operations/delete-requests
     */ async batchDeleteRequests(requests) {
        var _a;
        (0, ow_1.default)(requests, ow_1.default.array.ofType(ow_1.default.any(ow_1.default.object.partialShape({
            id: ow_1.default.string
        }), ow_1.default.object.partialShape({
            uniqueKey: ow_1.default.string
        }))).minLength(1).maxLength(consts_1.REQUEST_QUEUE_MAX_REQUESTS_PER_BATCH_OPERATION));
        const { data } = await this.httpClient.call({
            url: this._url('requests/batch'),
            method: 'DELETE',
            timeout: Math.min(resource_client_1.SMALL_TIMEOUT_MILLIS, (_a = this.timeoutMillis) !== null && _a !== void 0 ? _a : Infinity),
            data: requests,
            params: this._params({
                clientKey: this.clientKey
            })
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(data)));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/request/get-request
     */ async getRequest(id) {
        var _a;
        (0, ow_1.default)(id, ow_1.default.string);
        const requestOpts = {
            url: this._url(`requests/${id}`),
            method: 'GET',
            timeout: Math.min(resource_client_1.SMALL_TIMEOUT_MILLIS, (_a = this.timeoutMillis) !== null && _a !== void 0 ? _a : Infinity),
            params: this._params()
        };
        try {
            const response = await this.httpClient.call(requestOpts);
            return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
        } catch (err) {
            (0, utils_1.catchNotFoundOrThrow)(err);
        }
        return undefined;
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/request/update-request
     */ async updateRequest(request, options = {}) {
        var _a;
        (0, ow_1.default)(request, ow_1.default.object.partialShape({
            id: ow_1.default.string
        }));
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            forefront: ow_1.default.optional.boolean
        }));
        const response = await this.httpClient.call({
            url: this._url(`requests/${request.id}`),
            method: 'PUT',
            timeout: Math.min(resource_client_1.MEDIUM_TIMEOUT_MILLIS, (_a = this.timeoutMillis) !== null && _a !== void 0 ? _a : Infinity),
            data: request,
            params: this._params({
                forefront: options.forefront,
                clientKey: this.clientKey
            })
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    async deleteRequest(id) {
        var _a;
        (0, ow_1.default)(id, ow_1.default.string);
        await this.httpClient.call({
            url: this._url(`requests/${id}`),
            method: 'DELETE',
            timeout: Math.min(resource_client_1.SMALL_TIMEOUT_MILLIS, (_a = this.timeoutMillis) !== null && _a !== void 0 ? _a : Infinity),
            params: this._params({
                clientKey: this.clientKey
            })
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/request-lock/prolong-request-lock
     */ async prolongRequestLock(id, options) {
        var _a;
        (0, ow_1.default)(id, ow_1.default.string);
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            lockSecs: ow_1.default.number,
            forefront: ow_1.default.optional.boolean
        }));
        const response = await this.httpClient.call({
            url: this._url(`requests/${id}/lock`),
            method: 'PUT',
            timeout: Math.min(resource_client_1.MEDIUM_TIMEOUT_MILLIS, (_a = this.timeoutMillis) !== null && _a !== void 0 ? _a : Infinity),
            params: this._params({
                forefront: options.forefront,
                lockSecs: options.lockSecs,
                clientKey: this.clientKey
            })
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/request-lock/delete-request-lock
     */ async deleteRequestLock(id, options = {}) {
        var _a;
        (0, ow_1.default)(id, ow_1.default.string);
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            forefront: ow_1.default.optional.boolean
        }));
        await this.httpClient.call({
            url: this._url(`requests/${id}/lock`),
            method: 'DELETE',
            timeout: Math.min(resource_client_1.SMALL_TIMEOUT_MILLIS, (_a = this.timeoutMillis) !== null && _a !== void 0 ? _a : Infinity),
            params: this._params({
                forefront: options.forefront,
                clientKey: this.clientKey
            })
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/request-collection/list-requests
     */ async listRequests(options = {}) {
        var _a;
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number,
            exclusiveStartId: ow_1.default.optional.string
        }));
        const response = await this.httpClient.call({
            url: this._url('requests'),
            method: 'GET',
            timeout: Math.min(resource_client_1.MEDIUM_TIMEOUT_MILLIS, (_a = this.timeoutMillis) !== null && _a !== void 0 ? _a : Infinity),
            params: this._params({
                limit: options.limit,
                exclusiveStartId: options.exclusiveStartId,
                clientKey: this.clientKey
            })
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * https://docs.apify.com/api/v2/request-queue-requests-unlock-post
     */ async unlockRequests() {
        var _a;
        const response = await this.httpClient.call({
            url: this._url('requests/unlock'),
            method: 'POST',
            timeout: Math.min(resource_client_1.MEDIUM_TIMEOUT_MILLIS, (_a = this.timeoutMillis) !== null && _a !== void 0 ? _a : Infinity),
            params: this._params({
                clientKey: this.clientKey
            })
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/request-collection/list-requests
     *
     * Usage:
     * for await (const { items } of client.paginateRequests({ limit: 10 })) {
     *   items.forEach((request) => console.log(request));
     * }
     */ paginateRequests(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number,
            maxPageLimit: ow_1.default.optional.number,
            exclusiveStartId: ow_1.default.optional.string
        }));
        const { limit, exclusiveStartId, maxPageLimit = DEFAULT_REQUEST_QUEUE_REQUEST_PAGE_LIMIT } = options;
        return new utils_1.PaginationIterator({
            getPage: this.listRequests.bind(this),
            limit,
            exclusiveStartId,
            maxPageLimit
        });
    }
}
exports.RequestQueueClient = RequestQueueClient; //# sourceMappingURL=request_queue.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/run.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RunClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const log_1 = __turbopack_context__.r("[project]/node_modules/@apify/log/cjs/index.cjs [app-route] (ecmascript)");
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
const dataset_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/dataset.js [app-route] (ecmascript)");
const key_value_store_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/key_value_store.js [app-route] (ecmascript)");
const log_2 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/log.js [app-route] (ecmascript)");
const request_queue_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/request_queue.js [app-route] (ecmascript)");
const RUN_CHARGE_IDEMPOTENCY_HEADER = 'idempotency-key';
class RunClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            ...options,
            resourcePath: options.resourcePath || 'actor-runs'
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-runs/run-object/get-run
     */ async get(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            waitForFinish: ow_1.default.optional.number
        }));
        return this._get(options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-runs/abort-run/abort-run
     */ async abort(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            gracefully: ow_1.default.optional.boolean
        }));
        const response = await this.httpClient.call({
            url: this._url('abort'),
            method: 'POST',
            params: this._params(options)
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-runs/delete-run/delete-run
     */ async delete() {
        return this._delete();
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-runs/metamorph-run/metamorph-run
     */ async metamorph(targetActorId, input, options = {}) {
        (0, ow_1.default)(targetActorId, ow_1.default.string);
        // input can be anything, pointless to validate
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            contentType: ow_1.default.optional.string,
            build: ow_1.default.optional.string
        }));
        const safeTargetActorId = this._toSafeId(targetActorId);
        const params = {
            targetActorId: safeTargetActorId,
            build: options.build
        };
        const request = {
            url: this._url('metamorph'),
            method: 'POST',
            data: input,
            params: this._params(params),
            // Apify internal property. Tells the request serialization interceptor
            // to stringify functions to JSON, instead of omitting them.
            // TODO: remove this ts-expect-error once we have defined custom Apify axios configs
            // @ts-expect-error Custom Apify property
            stringifyFunctions: true
        };
        if (options.contentType) {
            request.headers = {
                'content-type': options.contentType
            };
        }
        const response = await this.httpClient.call(request);
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-runs/reboot-run/reboot-run
     */ async reboot() {
        const request = {
            url: this._url('reboot'),
            method: 'POST'
        };
        const response = await this.httpClient.call(request);
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    async update(newFields) {
        (0, ow_1.default)(newFields, ow_1.default.object);
        return this._update(newFields);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-runs/resurrect-run/resurrect-run
     */ async resurrect(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            build: ow_1.default.optional.string,
            memory: ow_1.default.optional.number,
            timeout: ow_1.default.optional.number,
            maxItems: ow_1.default.optional.number,
            maxTotalChargeUsd: ow_1.default.optional.number,
            restartOnError: ow_1.default.optional.boolean
        }));
        const response = await this.httpClient.call({
            url: this._url('resurrect'),
            method: 'POST',
            params: this._params(options)
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-runs/charge-events-in-run
     */ async charge(options) {
        var _a, _b;
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            eventName: ow_1.default.string,
            count: ow_1.default.optional.number,
            idempotencyKey: ow_1.default.optional.string
        }));
        const count = (_a = options.count) !== null && _a !== void 0 ? _a : 1;
        /** To avoid duplicates during the same milisecond, doesn't need to by crypto-secure. */ const randomSuffix = (Math.random() + 1).toString(36).slice(3, 8);
        const idempotencyKey = (_b = options.idempotencyKey) !== null && _b !== void 0 ? _b : `${this.id}-${options.eventName}-${Date.now()}-${randomSuffix}`;
        const request = {
            url: this._url('charge'),
            method: 'POST',
            data: {
                eventName: options.eventName,
                count
            },
            headers: {
                [RUN_CHARGE_IDEMPOTENCY_HEADER]: idempotencyKey
            }
        };
        const response = await this.httpClient.call(request);
        return response;
    }
    /**
     * Returns a promise that resolves with the finished Run object when the provided actor run finishes
     * or with the unfinished Run object when the `waitSecs` timeout lapses. The promise is NOT rejected
     * based on run status. You can inspect the `status` property of the Run object to find out its status.
     *
     * The difference between this function and the `waitForFinish` parameter of the `get` method
     * is the fact that this function can wait indefinitely. Its use is preferable to the
     * `waitForFinish` parameter alone, which it uses internally.
     *
     * This is useful when you need to chain actor executions. Similar effect can be achieved
     * by using webhooks, so be sure to review which technique fits your use-case better.
     */ async waitForFinish(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            waitSecs: ow_1.default.optional.number
        }));
        return this._waitForFinish(options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-runs/run-object-and-its-storages
     *
     * This also works through `actorClient.lastRun().dataset()`.
     * https://docs.apify.com/api/v2#/reference/actors/last-run-object-and-its-storages
     */ dataset() {
        return new dataset_1.DatasetClient(this._subResourceOptions({
            resourcePath: 'dataset'
        }));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-runs/run-object-and-its-storages
     *
     * This also works through `actorClient.lastRun().keyValueStore()`.
     * https://docs.apify.com/api/v2#/reference/actors/last-run-object-and-its-storages
     */ keyValueStore() {
        return new key_value_store_1.KeyValueStoreClient(this._subResourceOptions({
            resourcePath: 'key-value-store'
        }));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-runs/run-object-and-its-storages
     *
     * This also works through `actorClient.lastRun().requestQueue()`.
     * https://docs.apify.com/api/v2#/reference/actors/last-run-object-and-its-storages
     */ requestQueue() {
        return new request_queue_1.RequestQueueClient(this._subResourceOptions({
            resourcePath: 'request-queue'
        }));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-runs/run-object-and-its-storages
     *
     * This also works through `actorClient.lastRun().log()`.
     * https://docs.apify.com/api/v2#/reference/actors/last-run-object-and-its-storages
     */ log() {
        return new log_2.LogClient(this._subResourceOptions({
            resourcePath: 'log'
        }));
    }
    /**
     * Get StreamedLog for convenient streaming of the run log and their redirection.
     */ async getStreamedLog(options = {}) {
        var _a, _b, _c;
        const { fromStart = true } = options;
        let { toLog } = options;
        if (toLog === null || !(0, utils_1.isNode)()) {
            // Explicitly no logging or not in Node.js
            return undefined;
        }
        if (toLog === undefined || toLog === 'default') {
            // Create default StreamedLog
            // Get actor name and run id
            const runData = await this.get();
            const runId = (_a = runData === null || runData === void 0 ? void 0 : runData.id) !== null && _a !== void 0 ? _a : '';
            const actorId = (_b = runData === null || runData === void 0 ? void 0 : runData.actId) !== null && _b !== void 0 ? _b : '';
            const actorData = await this.apifyClient.actor(actorId).get() || {
                name: ''
            };
            const actorName = (_c = actorData === null || actorData === void 0 ? void 0 : actorData.name) !== null && _c !== void 0 ? _c : '';
            const name = [
                actorName,
                `runId:${runId}`
            ].filter(Boolean).join(' ');
            toLog = new log_1.Log({
                level: log_1.LEVELS.DEBUG,
                prefix: `${name} -> `,
                logger: new log_2.LoggerActorRedirect()
            });
        }
        return new log_2.StreamedLog({
            logClient: this.log(),
            toLog,
            fromStart
        });
    }
}
exports.RunClient = RunClient; //# sourceMappingURL=run.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/run_collection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RunCollectionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const consts_1 = __turbopack_context__.r("[project]/node_modules/@apify/consts/cjs/index.cjs [app-route] (ecmascript)");
const resource_collection_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)");
class RunCollectionClient extends resource_collection_client_1.ResourceCollectionClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'runs',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/run-collection/get-list-of-runs
     */ async list(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            desc: ow_1.default.optional.boolean,
            status: ow_1.default.optional.any(ow_1.default.string.oneOf(Object.values(consts_1.ACTOR_JOB_STATUSES)), ow_1.default.array.ofType(ow_1.default.string.oneOf(Object.values(consts_1.ACTOR_JOB_STATUSES)))),
            startedBefore: ow_1.default.optional.any(ow_1.default.optional.date, ow_1.default.optional.string),
            startedAfter: ow_1.default.optional.any(ow_1.default.optional.date, ow_1.default.optional.string)
        }));
        return this._list(options);
    }
}
exports.RunCollectionClient = RunCollectionClient; //# sourceMappingURL=run_collection.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/webhook_collection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebhookCollectionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_collection_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)");
class WebhookCollectionClient extends resource_collection_client_1.ResourceCollectionClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'webhooks',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/webhooks/webhook-collection/get-list-of-webhooks
     */ async list(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            desc: ow_1.default.optional.boolean
        }));
        return this._list(options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/webhooks/webhook-collection/create-webhook
     */ async create(webhook) {
        (0, ow_1.default)(webhook, ow_1.default.optional.object);
        return this._create(webhook);
    }
}
exports.WebhookCollectionClient = WebhookCollectionClient; //# sourceMappingURL=webhook_collection.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/actor.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ActorClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const consts_1 = __turbopack_context__.r("[project]/node_modules/@apify/consts/cjs/index.cjs [app-route] (ecmascript)");
const log_1 = __turbopack_context__.r("[project]/node_modules/@apify/log/cjs/index.cjs [app-route] (ecmascript)");
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
const actor_version_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/actor_version.js [app-route] (ecmascript)");
const actor_version_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/actor_version_collection.js [app-route] (ecmascript)");
const build_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/build.js [app-route] (ecmascript)");
const build_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/build_collection.js [app-route] (ecmascript)");
const run_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/run.js [app-route] (ecmascript)");
const run_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/run_collection.js [app-route] (ecmascript)");
const webhook_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/webhook_collection.js [app-route] (ecmascript)");
class ActorClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'acts',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/actor-object/get-actor
     */ async get() {
        return this._get();
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/actor-object/update-actor
     */ async update(newFields) {
        (0, ow_1.default)(newFields, ow_1.default.object);
        return this._update(newFields);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/actor-object/delete-actor
     */ async delete() {
        return this._delete();
    }
    /**
     * Starts an actor and immediately returns the Run object.
     * https://docs.apify.com/api/v2#/reference/actors/run-collection/run-actor
     */ async start(input, options = {}) {
        // input can be anything, so no point in validating it. E.g. if you set content-type to application/pdf
        // then it will process input as a buffer.
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            build: ow_1.default.optional.string,
            contentType: ow_1.default.optional.string,
            memory: ow_1.default.optional.number,
            timeout: ow_1.default.optional.number,
            waitForFinish: ow_1.default.optional.number,
            webhooks: ow_1.default.optional.array.ofType(ow_1.default.object),
            maxItems: ow_1.default.optional.number.not.negative,
            maxTotalChargeUsd: ow_1.default.optional.number.not.negative,
            restartOnError: ow_1.default.optional.boolean,
            forcePermissionLevel: ow_1.default.optional.string.oneOf(Object.values(consts_1.ACTOR_PERMISSION_LEVEL))
        }));
        const { waitForFinish, timeout, memory, build, maxItems, maxTotalChargeUsd, restartOnError, forcePermissionLevel } = options;
        const params = {
            waitForFinish,
            timeout,
            memory,
            build,
            webhooks: (0, utils_1.stringifyWebhooksToBase64)(options.webhooks),
            maxItems,
            maxTotalChargeUsd,
            restartOnError,
            forcePermissionLevel
        };
        const request = {
            url: this._url('runs'),
            method: 'POST',
            data: input,
            params: this._params(params),
            // Apify internal property. Tells the request serialization interceptor
            // to stringify functions to JSON, instead of omitting them.
            // TODO: remove this ts-expect-error once we migrate HttpClient to TS and define Apify
            // extension of Axios configs
            // @ts-expect-error Apify extension
            stringifyFunctions: true
        };
        if (options.contentType) {
            request.headers = {
                'content-type': options.contentType
            };
        }
        const response = await this.httpClient.call(request);
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * Starts an actor and waits for it to finish before returning the Run object.
     * It waits indefinitely, unless the `waitSecs` option is provided.
     * https://docs.apify.com/api/v2#/reference/actors/run-collection/run-actor
     */ async call(input, options = {}) {
        // input can be anything, so no point in validating it. E.g. if you set content-type to application/pdf
        // then it will process input as a buffer.
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            build: ow_1.default.optional.string,
            contentType: ow_1.default.optional.string,
            memory: ow_1.default.optional.number,
            timeout: ow_1.default.optional.number.not.negative,
            waitSecs: ow_1.default.optional.number.not.negative,
            webhooks: ow_1.default.optional.array.ofType(ow_1.default.object),
            maxItems: ow_1.default.optional.number.not.negative,
            maxTotalChargeUsd: ow_1.default.optional.number.not.negative,
            log: ow_1.default.optional.any(ow_1.default.null, ow_1.default.object.instanceOf(log_1.Log), ow_1.default.string.equals('default')),
            restartOnError: ow_1.default.optional.boolean,
            forcePermissionLevel: ow_1.default.optional.string.oneOf(Object.values(consts_1.ACTOR_PERMISSION_LEVEL))
        }));
        const { waitSecs, log, ...startOptions } = options;
        const { id } = await this.start(input, startOptions);
        // Calling root client because we need access to top level API.
        // Creating a new instance of RunClient here would only allow
        // setting it up as a nested route under actor API.
        const newRunClient = this.apifyClient.run(id);
        const streamedLog = await newRunClient.getStreamedLog({
            toLog: options === null || options === void 0 ? void 0 : options.log
        });
        streamedLog === null || streamedLog === void 0 ? void 0 : streamedLog.start();
        return this.apifyClient.run(id).waitForFinish({
            waitSecs
        }).finally(async ()=>{
            await (streamedLog === null || streamedLog === void 0 ? void 0 : streamedLog.stop());
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/build-collection/build-actor
     * @return {Promise<Build>}
     */ async build(versionNumber, options = {}) {
        (0, ow_1.default)(versionNumber, ow_1.default.string);
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            betaPackages: ow_1.default.optional.boolean,
            tag: ow_1.default.optional.string,
            useCache: ow_1.default.optional.boolean,
            waitForFinish: ow_1.default.optional.number
        }));
        const response = await this.httpClient.call({
            url: this._url('builds'),
            method: 'POST',
            params: this._params({
                version: versionNumber,
                ...options
            })
        });
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * https://docs.apify.com/api/v2/act-build-default-get
     */ async defaultBuild(options = {}) {
        const response = await this.httpClient.call({
            url: this._url('builds/default'),
            method: 'GET',
            params: this._params(options)
        });
        const { id } = (0, utils_1.pluckData)(response.data);
        return new build_1.BuildClient({
            baseUrl: this.apifyClient.baseUrl,
            publicBaseUrl: this.apifyClient.publicBaseUrl,
            httpClient: this.httpClient,
            apifyClient: this.apifyClient,
            id
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/last-run-object-and-its-storages
     */ lastRun(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            status: ow_1.default.optional.string.oneOf(Object.values(consts_1.ACT_JOB_STATUSES)),
            origin: ow_1.default.optional.string.oneOf(Object.values(consts_1.META_ORIGINS))
        }));
        return new run_1.RunClient(this._subResourceOptions({
            id: 'last',
            params: this._params(options),
            resourcePath: 'runs'
        }));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/build-collection
     */ builds() {
        return new build_collection_1.BuildCollectionClient(this._subResourceOptions({
            resourcePath: 'builds'
        }));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/run-collection
     */ runs() {
        return new run_collection_1.RunCollectionClient(this._subResourceOptions({
            resourcePath: 'runs'
        }));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/version-object
     */ version(versionNumber) {
        (0, ow_1.default)(versionNumber, ow_1.default.string);
        return new actor_version_1.ActorVersionClient(this._subResourceOptions({
            id: versionNumber
        }));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/version-collection
     * @return {ActorVersionCollectionClient}
     */ versions() {
        return new actor_version_collection_1.ActorVersionCollectionClient(this._subResourceOptions());
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/webhook-collection
     * @return {WebhookCollectionClient}
     */ webhooks() {
        return new webhook_collection_1.WebhookCollectionClient(this._subResourceOptions());
    }
}
exports.ActorClient = ActorClient; //# sourceMappingURL=actor.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/actor_collection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ActorListSortBy = exports.ActorCollectionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_collection_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)");
class ActorCollectionClient extends resource_collection_client_1.ResourceCollectionClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'acts',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/actor-collection/get-list-of-actors
     */ async list(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            my: ow_1.default.optional.boolean,
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            desc: ow_1.default.optional.boolean,
            sortBy: ow_1.default.optional.string.oneOf(Object.values(ActorListSortBy))
        }));
        return this._list(options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/actor-collection/create-actor
     */ async create(actor) {
        (0, ow_1.default)(actor, ow_1.default.optional.object);
        return this._create(actor);
    }
}
exports.ActorCollectionClient = ActorCollectionClient;
var ActorListSortBy;
(function(ActorListSortBy) {
    ActorListSortBy["CREATED_AT"] = "createdAt";
    ActorListSortBy["LAST_RUN_STARTED_AT"] = "stats.lastRunStartedAt";
})(ActorListSortBy || (exports.ActorListSortBy = ActorListSortBy = {})); //# sourceMappingURL=actor_collection.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/dataset_collection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DatasetCollectionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_collection_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)");
class DatasetCollectionClient extends resource_collection_client_1.ResourceCollectionClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'datasets',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/datasets/dataset-collection/get-list-of-datasets
     */ async list(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            unnamed: ow_1.default.optional.boolean,
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            desc: ow_1.default.optional.boolean
        }));
        return this._list(options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/datasets/dataset-collection/create-dataset
     */ async getOrCreate(name, options) {
        (0, ow_1.default)(name, ow_1.default.optional.string);
        (0, ow_1.default)(options === null || options === void 0 ? void 0 : options.schema, ow_1.default.optional.object); // TODO: Add schema validatioon
        return this._getOrCreate(name, options);
    }
}
exports.DatasetCollectionClient = DatasetCollectionClient; //# sourceMappingURL=dataset_collection.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/key_value_store_collection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KeyValueStoreCollectionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_collection_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)");
class KeyValueStoreCollectionClient extends resource_collection_client_1.ResourceCollectionClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'key-value-stores',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/key-value-stores/store-collection/get-list-of-key-value-stores
     */ async list(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            unnamed: ow_1.default.optional.boolean,
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            desc: ow_1.default.optional.boolean
        }));
        return this._list(options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/key-value-stores/store-collection/create-key-value-store
     */ async getOrCreate(name, options) {
        (0, ow_1.default)(name, ow_1.default.optional.string);
        (0, ow_1.default)(options === null || options === void 0 ? void 0 : options.schema, ow_1.default.optional.object); // TODO: Add schema validatioon
        return this._getOrCreate(name, options);
    }
}
exports.KeyValueStoreCollectionClient = KeyValueStoreCollectionClient; //# sourceMappingURL=key_value_store_collection.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/request_queue_collection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RequestQueueCollectionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_collection_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)");
class RequestQueueCollectionClient extends resource_collection_client_1.ResourceCollectionClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'request-queues',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/queue-collection/get-list-of-request-queues
     */ async list(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            unnamed: ow_1.default.optional.boolean,
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            desc: ow_1.default.optional.boolean
        }));
        return this._list(options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/queue-collection/create-request-queue
     */ async getOrCreate(name) {
        (0, ow_1.default)(name, ow_1.default.optional.string);
        return this._getOrCreate(name);
    }
}
exports.RequestQueueCollectionClient = RequestQueueCollectionClient; //# sourceMappingURL=request_queue_collection.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/schedule.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ScheduleActions = exports.ScheduleClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
class ScheduleClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'schedules',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/schedules/schedule-object/get-schedule
     */ async get() {
        return this._get();
    }
    /**
     * https://docs.apify.com/api/v2#/reference/schedules/schedule-object/update-schedule
     */ async update(newFields) {
        (0, ow_1.default)(newFields, ow_1.default.object);
        return this._update(newFields);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/schedules/schedule-object/delete-schedule
     */ async delete() {
        return this._delete();
    }
    /**
     * https://docs.apify.com/api/v2#/reference/schedules/schedule-log/get-schedule-log
     */ async getLog() {
        const requestOpts = {
            url: this._url('log'),
            method: 'GET',
            params: this._params()
        };
        try {
            const response = await this.httpClient.call(requestOpts);
            return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
        } catch (err) {
            (0, utils_1.catchNotFoundOrThrow)(err);
        }
        return undefined;
    }
}
exports.ScheduleClient = ScheduleClient;
var ScheduleActions;
(function(ScheduleActions) {
    ScheduleActions["RunActor"] = "RUN_ACTOR";
    ScheduleActions["RunActorTask"] = "RUN_ACTOR_TASK";
})(ScheduleActions || (exports.ScheduleActions = ScheduleActions = {})); //# sourceMappingURL=schedule.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/schedule_collection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ScheduleCollectionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_collection_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)");
class ScheduleCollectionClient extends resource_collection_client_1.ResourceCollectionClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'schedules',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/schedules/schedules-collection/get-list-of-schedules
     */ async list(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            desc: ow_1.default.optional.boolean
        }));
        return this._list(options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/schedules/schedules-collection/create-schedule
     */ async create(schedule) {
        (0, ow_1.default)(schedule, ow_1.default.optional.object);
        return this._create(schedule);
    }
}
exports.ScheduleCollectionClient = ScheduleCollectionClient; //# sourceMappingURL=schedule_collection.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/store_collection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StoreCollectionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_collection_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)");
class StoreCollectionClient extends resource_collection_client_1.ResourceCollectionClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'store',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2/#/reference/store/store-actors-collection/get-list-of-actors-in-store
     */ async list(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            search: ow_1.default.optional.string,
            sortBy: ow_1.default.optional.string,
            category: ow_1.default.optional.string,
            username: ow_1.default.optional.string,
            pricingModel: ow_1.default.optional.string
        }));
        return this._list(options);
    }
}
exports.StoreCollectionClient = StoreCollectionClient; //# sourceMappingURL=store_collection.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/task.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TaskClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const consts_1 = __turbopack_context__.r("[project]/node_modules/@apify/consts/cjs/index.cjs [app-route] (ecmascript)");
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
const run_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/run.js [app-route] (ecmascript)");
const run_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/run_collection.js [app-route] (ecmascript)");
const webhook_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/webhook_collection.js [app-route] (ecmascript)");
class TaskClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'actor-tasks',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-tasks/task-object/get-task
     */ async get() {
        return this._get();
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-tasks/task-object/update-task
     */ async update(newFields) {
        (0, ow_1.default)(newFields, ow_1.default.object);
        return this._update(newFields);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-tasks/task-object/delete-task
     */ async delete() {
        return this._delete();
    }
    /**
     * Starts a task and immediately returns the Run object.
     * https://docs.apify.com/api/v2#/reference/actor-tasks/run-collection/run-task
     */ async start(input, options = {}) {
        (0, ow_1.default)(input, ow_1.default.optional.object);
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            build: ow_1.default.optional.string,
            memory: ow_1.default.optional.number,
            timeout: ow_1.default.optional.number,
            waitForFinish: ow_1.default.optional.number,
            webhooks: ow_1.default.optional.array.ofType(ow_1.default.object),
            maxItems: ow_1.default.optional.number.not.negative,
            maxTotalChargeUsd: ow_1.default.optional.number.not.negative,
            restartOnError: ow_1.default.optional.boolean
        }));
        const { waitForFinish, timeout, memory, build, maxItems, maxTotalChargeUsd, restartOnError } = options;
        const params = {
            waitForFinish,
            timeout,
            memory,
            build,
            webhooks: (0, utils_1.stringifyWebhooksToBase64)(options.webhooks),
            maxItems,
            maxTotalChargeUsd,
            restartOnError
        };
        const request = {
            url: this._url('runs'),
            method: 'POST',
            data: input,
            params: this._params(params),
            // Apify internal property. Tells the request serialization interceptor
            // to stringify functions to JSON, instead of omitting them.
            stringifyFunctions: true,
            headers: {
                'Content-Type': 'application/json'
            }
        };
        const response = await this.httpClient.call(request);
        return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
    }
    /**
     * Starts a task and waits for it to finish before returning the Run object.
     * It waits indefinitely, unless the `waitSecs` option is provided.
     * https://docs.apify.com/api/v2#/reference/actor-tasks/run-collection/run-task
     */ async call(input, options = {}) {
        (0, ow_1.default)(input, ow_1.default.optional.object);
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            build: ow_1.default.optional.string,
            memory: ow_1.default.optional.number,
            timeout: ow_1.default.optional.number.not.negative,
            waitSecs: ow_1.default.optional.number.not.negative,
            webhooks: ow_1.default.optional.array.ofType(ow_1.default.object),
            maxItems: ow_1.default.optional.number.not.negative,
            maxTotalChargeUsd: ow_1.default.optional.number.not.negative,
            restartOnError: ow_1.default.optional.boolean
        }));
        const { waitSecs, ...startOptions } = options;
        const { id } = await this.start(input, startOptions);
        // Calling root client because we need access to top level API.
        // Creating a new instance of RunClient here would only allow
        // setting it up as a nested route under task API.
        return this.apifyClient.run(id).waitForFinish({
            waitSecs
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-tasks/task-input-object/get-task-input
     */ async getInput() {
        const requestOpts = {
            url: this._url('input'),
            method: 'GET',
            params: this._params()
        };
        try {
            const response = await this.httpClient.call(requestOpts);
            return (0, utils_1.cast)(response.data);
        } catch (err) {
            (0, utils_1.catchNotFoundOrThrow)(err);
        }
        return undefined;
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-tasks/task-input-object/update-task-input
     */ async updateInput(newFields) {
        const response = await this.httpClient.call({
            url: this._url('input'),
            method: 'PUT',
            params: this._params(),
            data: newFields
        });
        return (0, utils_1.cast)(response.data);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-tasks/last-run-object-and-its-storages
     */ lastRun(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            status: ow_1.default.optional.string.oneOf(Object.values(consts_1.ACT_JOB_STATUSES)),
            origin: ow_1.default.optional.string.oneOf(Object.values(consts_1.META_ORIGINS))
        }));
        return new run_1.RunClient(this._subResourceOptions({
            id: 'last',
            params: this._params(options),
            resourcePath: 'runs'
        }));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-tasks/run-collection
     */ runs() {
        return new run_collection_1.RunCollectionClient(this._subResourceOptions({
            resourcePath: 'runs'
        }));
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-tasks/webhook-collection
     */ webhooks() {
        return new webhook_collection_1.WebhookCollectionClient(this._subResourceOptions());
    }
}
exports.TaskClient = TaskClient; //# sourceMappingURL=task.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/task_collection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TaskCollectionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_collection_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)");
class TaskCollectionClient extends resource_collection_client_1.ResourceCollectionClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'actor-tasks',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-tasks/task-collection/get-list-of-tasks
     * @param {object} [options]
     * @param {number} [options.limit]
     * @param {number} [options.offset]
     * @param {boolean} [options.desc]
     * @return {Promise<PaginationList>}
     */ async list(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            desc: ow_1.default.optional.boolean
        }));
        return this._list(options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-tasks/task-collection/create-task
     */ async create(task) {
        (0, ow_1.default)(task, ow_1.default.object);
        return this._create(task);
    }
}
exports.TaskCollectionClient = TaskCollectionClient; //# sourceMappingURL=task_collection.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/user.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PlatformFeature = exports.UserClient = void 0;
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
class UserClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'users',
            ...options
        });
    }
    /**
     * Depending on whether ApifyClient was created with a token,
     * the method will either return public or private user data.
     * https://docs.apify.com/api/v2#/reference/users
     */ async get() {
        return this._get();
    }
    /**
     * https://docs.apify.com/api/v2/#/reference/users/monthly-usage
     */ async monthlyUsage() {
        const requestOpts = {
            url: this._url('usage/monthly'),
            method: 'GET',
            params: this._params()
        };
        try {
            const response = await this.httpClient.call(requestOpts);
            return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data), // Convert  monthlyUsage.dailyServiceUsages[].date to Date (by default it's ignored by parseDateFields)
            /* shouldParseField = */ (key)=>key === 'date'));
        } catch (err) {
            (0, utils_1.catchNotFoundOrThrow)(err);
        }
        return undefined;
    }
    /**
     * https://docs.apify.com/api/v2/#/reference/users/account-and-usage-limits
     */ async limits() {
        const requestOpts = {
            url: this._url('limits'),
            method: 'GET',
            params: this._params()
        };
        try {
            const response = await this.httpClient.call(requestOpts);
            return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
        } catch (err) {
            (0, utils_1.catchNotFoundOrThrow)(err);
        }
        return undefined;
    }
    /**
     * https://docs.apify.com/api/v2/#/reference/users/account-and-usage-limits
     */ async updateLimits(options) {
        const requestOpts = {
            url: this._url('limits'),
            method: 'PUT',
            params: this._params(),
            data: options
        };
        await this.httpClient.call(requestOpts);
    }
}
exports.UserClient = UserClient;
var PlatformFeature;
(function(PlatformFeature) {
    PlatformFeature["Actors"] = "ACTORS";
    PlatformFeature["Storage"] = "STORAGE";
    PlatformFeature["ProxySERPS"] = "PROXY_SERPS";
    PlatformFeature["Scheduler"] = "SCHEDULER";
    PlatformFeature["Webhooks"] = "WEBHOOKS";
    PlatformFeature["Proxy"] = "PROXY";
    PlatformFeature["ProxyExternalAccess"] = "PROXY_EXTERNAL_ACCESS";
})(PlatformFeature || (exports.PlatformFeature = PlatformFeature = {})); //# sourceMappingURL=user.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/webhook_dispatch_collection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebhookDispatchCollectionClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_collection_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_collection_client.js [app-route] (ecmascript)");
class WebhookDispatchCollectionClient extends resource_collection_client_1.ResourceCollectionClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'webhook-dispatches',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/webhook-dispatches/webhook-dispatches-collection/get-list-of-webhook-dispatches
     */ async list(options = {}) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            limit: ow_1.default.optional.number,
            offset: ow_1.default.optional.number,
            desc: ow_1.default.optional.boolean
        }));
        return this._list(options);
    }
}
exports.WebhookDispatchCollectionClient = WebhookDispatchCollectionClient; //# sourceMappingURL=webhook_dispatch_collection.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/webhook.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebhookClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/utils.js [app-route] (ecmascript)");
const webhook_dispatch_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/webhook_dispatch_collection.js [app-route] (ecmascript)");
class WebhookClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'webhooks',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/webhooks/webhook-object/get-webhook
     */ async get() {
        return this._get();
    }
    /**
     * https://docs.apify.com/api/v2#/reference/webhooks/webhook-object/update-webhook
     */ async update(newFields) {
        (0, ow_1.default)(newFields, ow_1.default.object);
        return this._update(newFields);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/webhooks/webhook-object/delete-webhook
     */ async delete() {
        return this._delete();
    }
    /**
     * https://docs.apify.com/api/v2#/reference/webhooks/webhook-test/test-webhook
     */ async test() {
        const request = {
            url: this._url('test'),
            method: 'POST',
            params: this._params()
        };
        try {
            const response = await this.httpClient.call(request);
            return (0, utils_1.cast)((0, utils_1.parseDateFields)((0, utils_1.pluckData)(response.data)));
        } catch (err) {
            (0, utils_1.catchNotFoundOrThrow)(err);
        }
        return undefined;
    }
    /**
     * https://docs.apify.com/api/v2#/reference/webhooks/dispatches-collection
     */ dispatches() {
        return new webhook_dispatch_collection_1.WebhookDispatchCollectionClient(this._subResourceOptions({
            resourcePath: 'dispatches'
        }));
    }
}
exports.WebhookClient = WebhookClient; //# sourceMappingURL=webhook.js.map
}),
"[project]/node_modules/apify-client/dist/resource_clients/webhook_dispatch.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebhookDispatchStatus = exports.WebhookDispatchClient = void 0;
const resource_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/base/resource_client.js [app-route] (ecmascript)");
class WebhookDispatchClient extends resource_client_1.ResourceClient {
    /**
     * @hidden
     */ constructor(options){
        super({
            resourcePath: 'webhook-dispatches',
            ...options
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/webhook-dispatches/webhook-dispatch-object/get-webhook-dispatch
     */ async get() {
        return this._get();
    }
}
exports.WebhookDispatchClient = WebhookDispatchClient;
var WebhookDispatchStatus;
(function(WebhookDispatchStatus) {
    WebhookDispatchStatus["Active"] = "ACTIVE";
    WebhookDispatchStatus["Succeeded"] = "SUCCEEDED";
    WebhookDispatchStatus["Failed"] = "FAILED";
})(WebhookDispatchStatus || (exports.WebhookDispatchStatus = WebhookDispatchStatus = {})); //# sourceMappingURL=webhook_dispatch.js.map
}),
"[project]/node_modules/apify-client/dist/statistics.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Statistics = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
class Statistics {
    constructor(){
        /**
         * Number of Apify client function calls
         */ Object.defineProperty(this, "calls", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        /**
         * Number of Apify API requests
         */ Object.defineProperty(this, "requests", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        /**
         * Number of times the API returned 429 error. Errors on first attempt are
         * counted at index 0. First retry error counts are on index 1 and so on.
         */ Object.defineProperty(this, "rateLimitErrors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    addRateLimitError(attempt) {
        (0, ow_1.default)(attempt, ow_1.default.number.greaterThan(0));
        // attempt is never 0,
        // but we don't want index 0 empty
        const index = attempt - 1;
        this._fillBlanksWithZeroes(index);
        this.rateLimitErrors[index]++;
    }
    /**
     * Removes the necessity to pre-initialize array with correct
     * number of zeroes by dynamically filling the empty indexes
     * when necessary.
     */ _fillBlanksWithZeroes(inclusiveIndex) {
        if (this.rateLimitErrors.length <= inclusiveIndex) {
            for(let k = 0; k <= inclusiveIndex; k++){
                if (typeof this.rateLimitErrors[k] !== 'number') {
                    this.rateLimitErrors[k] = 0;
                }
            }
        }
    }
}
exports.Statistics = Statistics; //# sourceMappingURL=statistics.js.map
}),
"[project]/node_modules/apify-client/dist/apify_client.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApifyClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ow_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ow/dist/index.js [app-route] (ecmascript)"));
const consts_1 = __turbopack_context__.r("[project]/node_modules/@apify/consts/cjs/index.cjs [app-route] (ecmascript)");
const log_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@apify/log/cjs/index.cjs [app-route] (ecmascript)"));
const http_client_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/http_client.js [app-route] (ecmascript)");
const actor_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/actor.js [app-route] (ecmascript)");
const actor_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/actor_collection.js [app-route] (ecmascript)");
const build_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/build.js [app-route] (ecmascript)");
const build_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/build_collection.js [app-route] (ecmascript)");
const dataset_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/dataset.js [app-route] (ecmascript)");
const dataset_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/dataset_collection.js [app-route] (ecmascript)");
const key_value_store_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/key_value_store.js [app-route] (ecmascript)");
const key_value_store_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/key_value_store_collection.js [app-route] (ecmascript)");
const log_2 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/log.js [app-route] (ecmascript)");
const request_queue_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/request_queue.js [app-route] (ecmascript)");
const request_queue_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/request_queue_collection.js [app-route] (ecmascript)");
const run_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/run.js [app-route] (ecmascript)");
const run_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/run_collection.js [app-route] (ecmascript)");
const schedule_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/schedule.js [app-route] (ecmascript)");
const schedule_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/schedule_collection.js [app-route] (ecmascript)");
const store_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/store_collection.js [app-route] (ecmascript)");
const task_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/task.js [app-route] (ecmascript)");
const task_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/task_collection.js [app-route] (ecmascript)");
const user_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/user.js [app-route] (ecmascript)");
const webhook_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/webhook.js [app-route] (ecmascript)");
const webhook_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/webhook_collection.js [app-route] (ecmascript)");
const webhook_dispatch_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/webhook_dispatch.js [app-route] (ecmascript)");
const webhook_dispatch_collection_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/webhook_dispatch_collection.js [app-route] (ecmascript)");
const statistics_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/statistics.js [app-route] (ecmascript)");
const DEFAULT_TIMEOUT_SECS = 360;
/**
 * ApifyClient is the official library to access [Apify API](https://docs.apify.com/api/v2) from your
 * JavaScript applications. It runs both in Node.js and browser.
 */ class ApifyClient {
    constructor(options = {}){
        Object.defineProperty(this, "baseUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "publicBaseUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "token", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "stats", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "httpClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            baseUrl: ow_1.default.optional.string,
            publicBaseUrl: ow_1.default.optional.string,
            maxRetries: ow_1.default.optional.number,
            minDelayBetweenRetriesMillis: ow_1.default.optional.number,
            requestInterceptors: ow_1.default.optional.array,
            timeoutSecs: ow_1.default.optional.number,
            token: ow_1.default.optional.string,
            userAgentSuffix: ow_1.default.optional.any(ow_1.default.string, ow_1.default.array.ofType(ow_1.default.string))
        }));
        const { baseUrl = 'https://api.apify.com', publicBaseUrl = 'https://api.apify.com', maxRetries = 8, minDelayBetweenRetriesMillis = 500, requestInterceptors = [], timeoutSecs = DEFAULT_TIMEOUT_SECS, token } = options;
        const tempBaseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, baseUrl.length - 1) : baseUrl;
        this.baseUrl = `${tempBaseUrl}/v2`;
        const tempPublicBaseUrl = publicBaseUrl.endsWith('/') ? publicBaseUrl.slice(0, publicBaseUrl.length - 1) : publicBaseUrl;
        this.publicBaseUrl = `${tempPublicBaseUrl}/v2`;
        this.token = token;
        this.stats = new statistics_1.Statistics();
        this.logger = log_1.default.child({
            prefix: 'ApifyClient'
        });
        this.httpClient = new http_client_1.HttpClient({
            apifyClientStats: this.stats,
            maxRetries,
            minDelayBetweenRetriesMillis,
            requestInterceptors,
            timeoutSecs,
            logger: this.logger,
            token: this.token,
            userAgentSuffix: options.userAgentSuffix
        });
    }
    _options() {
        return {
            baseUrl: this.baseUrl,
            publicBaseUrl: this.publicBaseUrl,
            apifyClient: this,
            httpClient: this.httpClient
        };
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/actor-collection
     */ actors() {
        return new actor_collection_1.ActorCollectionClient(this._options());
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actors/actor-object
     */ actor(id) {
        (0, ow_1.default)(id, ow_1.default.string.nonEmpty);
        return new actor_1.ActorClient({
            id,
            ...this._options()
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-builds/build-collection
     */ builds() {
        return new build_collection_1.BuildCollectionClient(this._options());
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-builds/build-object
     */ build(id) {
        (0, ow_1.default)(id, ow_1.default.string.nonEmpty);
        return new build_1.BuildClient({
            id,
            ...this._options()
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/datasets/dataset-collection
     */ datasets() {
        return new dataset_collection_1.DatasetCollectionClient(this._options());
    }
    /**
     * https://docs.apify.com/api/v2#/reference/datasets/dataset
     */ dataset(id) {
        (0, ow_1.default)(id, ow_1.default.string.nonEmpty);
        return new dataset_1.DatasetClient({
            id,
            ...this._options()
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/key-value-stores/store-collection
     */ keyValueStores() {
        return new key_value_store_collection_1.KeyValueStoreCollectionClient(this._options());
    }
    /**
     * https://docs.apify.com/api/v2#/reference/key-value-stores/store-object
     */ keyValueStore(id) {
        (0, ow_1.default)(id, ow_1.default.string.nonEmpty);
        return new key_value_store_1.KeyValueStoreClient({
            id,
            ...this._options()
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/logs
     */ log(buildOrRunId) {
        (0, ow_1.default)(buildOrRunId, ow_1.default.string.nonEmpty);
        return new log_2.LogClient({
            id: buildOrRunId,
            ...this._options()
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/queue-collection
     */ requestQueues() {
        return new request_queue_collection_1.RequestQueueCollectionClient(this._options());
    }
    /**
     * https://docs.apify.com/api/v2#/reference/request-queues/queue
     */ requestQueue(id, options = {}) {
        (0, ow_1.default)(id, ow_1.default.string.nonEmpty);
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            clientKey: ow_1.default.optional.string.nonEmpty,
            timeoutSecs: ow_1.default.optional.number
        }));
        const apiClientOptions = {
            id,
            ...this._options()
        };
        return new request_queue_1.RequestQueueClient(apiClientOptions, options);
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-runs/run-collection
     */ runs() {
        return new run_collection_1.RunCollectionClient({
            ...this._options(),
            resourcePath: 'actor-runs'
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-runs/run-object-and-its-storages
     */ run(id) {
        (0, ow_1.default)(id, ow_1.default.string.nonEmpty);
        return new run_1.RunClient({
            id,
            ...this._options()
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-tasks/task-collection
     */ tasks() {
        return new task_collection_1.TaskCollectionClient(this._options());
    }
    /**
     * https://docs.apify.com/api/v2#/reference/actor-tasks/task-object
     */ task(id) {
        (0, ow_1.default)(id, ow_1.default.string.nonEmpty);
        return new task_1.TaskClient({
            id,
            ...this._options()
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/schedules/schedules-collection
     */ schedules() {
        return new schedule_collection_1.ScheduleCollectionClient(this._options());
    }
    /**
     * https://docs.apify.com/api/v2#/reference/schedules/schedule-object
     */ schedule(id) {
        (0, ow_1.default)(id, ow_1.default.string.nonEmpty);
        return new schedule_1.ScheduleClient({
            id,
            ...this._options()
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/users
     */ user(id = consts_1.ME_USER_NAME_PLACEHOLDER) {
        (0, ow_1.default)(id, ow_1.default.string.nonEmpty);
        return new user_1.UserClient({
            id,
            ...this._options()
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/webhooks/webhook-collection
     */ webhooks() {
        return new webhook_collection_1.WebhookCollectionClient(this._options());
    }
    /**
     * https://docs.apify.com/api/v2#/reference/webhooks/webhook-object
     */ webhook(id) {
        (0, ow_1.default)(id, ow_1.default.string.nonEmpty);
        return new webhook_1.WebhookClient({
            id,
            ...this._options()
        });
    }
    /**
     * https://docs.apify.com/api/v2#/reference/webhook-dispatches
     */ webhookDispatches() {
        return new webhook_dispatch_collection_1.WebhookDispatchCollectionClient(this._options());
    }
    /**
     * https://docs.apify.com/api/v2#/reference/webhook-dispatches/webhook-dispatch-object
     */ webhookDispatch(id) {
        (0, ow_1.default)(id, ow_1.default.string.nonEmpty);
        return new webhook_dispatch_1.WebhookDispatchClient({
            id,
            ...this._options()
        });
    }
    /**
     * https://docs.apify.com/api/v2/#/reference/store
     */ store() {
        return new store_collection_1.StoreCollectionClient(this._options());
    }
    async setStatusMessage(message, options) {
        const runId = process.env[consts_1.ACTOR_ENV_VARS.RUN_ID];
        if (!runId) {
            throw new Error(`Environment variable ${consts_1.ACTOR_ENV_VARS.RUN_ID} is not set!`);
        }
        await this.run(runId).update({
            statusMessage: message,
            ...options
        });
    }
}
exports.ApifyClient = ApifyClient; //# sourceMappingURL=apify_client.js.map
}),
"[project]/node_modules/apify-client/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidResponseBodyError = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/apify_client.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/actor.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/actor_collection.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/actor_env_var.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/actor_env_var_collection.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/actor_version.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/actor_version_collection.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/build.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/build_collection.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/dataset.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/dataset_collection.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/key_value_store.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/key_value_store_collection.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/log.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/request_queue.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/request_queue_collection.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/run.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/run_collection.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/schedule.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/schedule_collection.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/store_collection.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/task.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/task_collection.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/user.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/webhook.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/webhook_collection.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/webhook_dispatch.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/resource_clients/webhook_dispatch_collection.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apify-client/dist/apify_api_error.js [app-route] (ecmascript)"), exports);
var interceptors_1 = __turbopack_context__.r("[project]/node_modules/apify-client/dist/interceptors.js [app-route] (ecmascript)");
Object.defineProperty(exports, "InvalidResponseBodyError", {
    enumerable: true,
    get: function() {
        return interceptors_1.InvalidResponseBodyError;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/apify-client/dist/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ActorClient",
    ()=>ActorClient,
    "ActorCollectionClient",
    ()=>ActorCollectionClient,
    "ActorEnvVarClient",
    ()=>ActorEnvVarClient,
    "ActorEnvVarCollectionClient",
    ()=>ActorEnvVarCollectionClient,
    "ActorListSortBy",
    ()=>ActorListSortBy,
    "ActorSourceType",
    ()=>ActorSourceType,
    "ActorVersionClient",
    ()=>ActorVersionClient,
    "ActorVersionCollectionClient",
    ()=>ActorVersionCollectionClient,
    "ApifyApiError",
    ()=>ApifyApiError,
    "ApifyClient",
    ()=>ApifyClient,
    "BuildClient",
    ()=>BuildClient,
    "BuildCollectionClient",
    ()=>BuildCollectionClient,
    "DatasetClient",
    ()=>DatasetClient,
    "DatasetCollectionClient",
    ()=>DatasetCollectionClient,
    "DownloadItemsFormat",
    ()=>DownloadItemsFormat,
    "InvalidResponseBodyError",
    ()=>InvalidResponseBodyError,
    "KeyValueStoreClient",
    ()=>KeyValueStoreClient,
    "KeyValueStoreCollectionClient",
    ()=>KeyValueStoreCollectionClient,
    "LogClient",
    ()=>LogClient,
    "LoggerActorRedirect",
    ()=>LoggerActorRedirect,
    "PlatformFeature",
    ()=>PlatformFeature,
    "RequestQueueClient",
    ()=>RequestQueueClient,
    "RequestQueueCollectionClient",
    ()=>RequestQueueCollectionClient,
    "RunClient",
    ()=>RunClient,
    "RunCollectionClient",
    ()=>RunCollectionClient,
    "ScheduleActions",
    ()=>ScheduleActions,
    "ScheduleClient",
    ()=>ScheduleClient,
    "ScheduleCollectionClient",
    ()=>ScheduleCollectionClient,
    "StoreCollectionClient",
    ()=>StoreCollectionClient,
    "StreamedLog",
    ()=>StreamedLog,
    "TaskClient",
    ()=>TaskClient,
    "TaskCollectionClient",
    ()=>TaskCollectionClient,
    "UserClient",
    ()=>UserClient,
    "WebhookClient",
    ()=>WebhookClient,
    "WebhookCollectionClient",
    ()=>WebhookCollectionClient,
    "WebhookDispatchClient",
    ()=>WebhookDispatchClient,
    "WebhookDispatchCollectionClient",
    ()=>WebhookDispatchCollectionClient,
    "WebhookDispatchStatus",
    ()=>WebhookDispatchStatus,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/apify-client/dist/index.js [app-route] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
const ActorClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ActorClient;
const ActorCollectionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ActorCollectionClient;
const ActorEnvVarClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ActorEnvVarClient;
const ActorEnvVarCollectionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ActorEnvVarCollectionClient;
const ActorListSortBy = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ActorListSortBy;
const ActorSourceType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ActorSourceType;
const ActorVersionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ActorVersionClient;
const ActorVersionCollectionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ActorVersionCollectionClient;
const ApifyApiError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ApifyApiError;
const ApifyClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ApifyClient;
const BuildClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].BuildClient;
const BuildCollectionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].BuildCollectionClient;
const DatasetClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].DatasetClient;
const DatasetCollectionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].DatasetCollectionClient;
const DownloadItemsFormat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].DownloadItemsFormat;
const InvalidResponseBodyError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].InvalidResponseBodyError;
const KeyValueStoreClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].KeyValueStoreClient;
const KeyValueStoreCollectionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].KeyValueStoreCollectionClient;
const LogClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].LogClient;
const LoggerActorRedirect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].LoggerActorRedirect;
const PlatformFeature = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].PlatformFeature;
const RequestQueueClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].RequestQueueClient;
const RequestQueueCollectionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].RequestQueueCollectionClient;
const RunClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].RunClient;
const RunCollectionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].RunCollectionClient;
const ScheduleActions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ScheduleActions;
const ScheduleClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ScheduleClient;
const ScheduleCollectionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ScheduleCollectionClient;
const StoreCollectionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].StoreCollectionClient;
const StreamedLog = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].StreamedLog;
const TaskClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].TaskClient;
const TaskCollectionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].TaskCollectionClient;
const UserClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].UserClient;
const WebhookClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].WebhookClient;
const WebhookCollectionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].WebhookCollectionClient;
const WebhookDispatchClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].WebhookDispatchClient;
const WebhookDispatchCollectionClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].WebhookDispatchCollectionClient;
const WebhookDispatchStatus = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apify$2d$client$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].WebhookDispatchStatus;
}),
];

//# sourceMappingURL=node_modules_apify-client_b95863ce._.js.map